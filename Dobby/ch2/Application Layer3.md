## P2P 파일 분배

웹, 전자메일, DNS는 모두 켜져 있는 서버에 상당히 의존하는 클라이언트-서버 구조를 채택하고 있다.

하지만 P2P 구조는 서버에 최소한으로 의존하며 대신 간헐적으로 연결되는 호스트(피어) 쌍들이 서로 직접 통신한다.

피어는 서비스 제공자가 소유하는 것이 아니라 사용자가 제어하는 데스크톱과 랩톱, 스마트폰이 소유한다.

클라이언트-서버 파일 분배에서 서버는 파일 복사본을 각 피어들에게 보내야 한다.

이는 서버에게 커다란 부하를 주고 많은 양의 서버 대역폭을 소비한다.

P2P 파일 분배에서 각 피어는 수신한 파일의 임의의 부분을 다른 피어들에게 재분배할 수 있어서 서버의 분배 프로세스를 도울 수 있다.

<br />

### 자가 확장성

P2P 구조는 클라이언트-서버 구조의 분배 시간보다 적은 시간이 소요되며 P2P 구조를 가진 애플리케이션은 자가 확장성을 갖는다.

따라서 피어는 소비자이자 재분배자가 될 수 있다.

<br />

## 스트리밍 및 DASH

녹화된 비디오는 서버에 저장되어 사용자가 비디오 시청을 서버에게 온디맨드로 요청한다.

비디오의 중요한 특징은 압축될 수 있다는 것인데, 비디오 품질과 비트 전송률은 서로 반비례한다. (trade-off)

스트리밍 비디오에서 가장 중요한 성능 척도는 종단 간 평균 처리량이며, 연속재생을 제공하기 위해 네트워크는 압축된 비디오의 전송률 이상의 스트리밍 애플리케이션에 대한 평균 처리량을 제공해야 한다.

또한 압축을 사용하여 동일한 비디오를 여러 버전의 품질로 만들 수 있다.

<br />

### DASH

서버가 HTTP 응답 메시지 내에서 비디오 파일을 전송하면, 클라이언트 쪽에선 애플리케이션 버퍼에 전송된 바이트가 저장된다.

이 버퍼의 바이트 수가 미리 정해진 임계값을 초과하면 클라이언트 애플리케이션이 재생을 시작한다.

클라이언트로 데이터를 보내는 과정에서 가용 대역폭의 차이는 각기 다른 클라이언트들 간에 존재할 뿐만 아니라 동일한 클라이언트에서도 시간에 따른 차이가 발생한다.

이를 개선하기 위해 HTTP 기반 스트리밍인 DASH가 개발되었다.

<br />

### DASH 동작 방법

DASH에서 비디오는 여러 가지 버전으로 인코딩되며, 각 버전은 비트율과 품질 수준이 서로 다르다.

클라이언트는 동적으로 서로 다른 버전의 비디오를 몇 초 분량의 길이를 갖는 비디오 조각 단위로 요청한다.

가용 대역폭이 충분할 때는 높은 비트율의 비디오 버전을 요청하며, 가용 대역폭이 적을 때는 낮은 비트율의 비디오 버전을 요청한다.

DASH를 사용할 대, 각 비디오 버전은 HTTP 서버에 서로 다른 URL을 가지고 저장된다.

HTTP 서버는 비트율에 따른 각 버전의 URL을 제공하는 매니페스트 파일(manifest file)을 갖고 있다.

클라이언트는 먼저 매니페스트 파일을 요청하여 서버에서 제공되는 다양한 버전에 대해 알게 된다.

이후 클라이언트는 매번 원하는 버전의 비디오 조각 단위 데이터를 선택하여 HTTP GET 요청 메시지에 URL과 byte-range를 지정하여 요청한다.

즉, DASH는 클라이언트가 서로 다른 품질 수준을 자유롭게 변화시킬 수 있도록 허용한다.

<br />

## CDN

`Content Delivery Network`

엄청난 데이터를 전 세계에 걸친 지점에 안정적으로 제공하는 것은 매우 어려운 문제이다.

서비스를 제공하는 가장 단순한 방법은 단일 데이터 센터를 구축하여 전 세계의 사용자에게 데이터 센터로부터 직접 전송하는 것이다.

하지만 이는 문제가 있다.

<br />

1. 클라리언트가 데이터 센터로부터 지역적으로 먼 지점에 있는 경우, 종단 간 처리율이 낮아 좋지 않은 사용자 경험을 제공하게 된다.

2. 인기 있는 데이터는 같은 통신 링크를 통해 여러 번 반복적으로 전송된다.

3. 단일 데이터 센터는 한 번의 장애로 인해 전체 서비스가 중단될 수 있는 위험이 있다.

<br />

이렇듯 엄청난 양의 데이터를 분배하는 문제를 해결하기 위해 거의 대부분의 네트워크 기업은 CDN(콘텐츠 분배 네트워크)를 이용한다.

CDN은 지리적으로 분산된 서버들을 연결한 네트워크로서 웹 컨텐츠의 복사본을 사용자에 가까운 곳에 두거나 동적 컨텐츠의 전달을 활성화하여 웹 성능 및 속도를 향상할 수 있게 한다.

각 CDN 서버는 이른바 ‘네트워크 엣지’에 위치한다. 웹사이트의 출처라 할 수 있는 호스트 서버와 비교하면 사용자와의 거리가 더 가깝다.

이러한 이유로 CDN 서버는 흔히 `엣지 서버`로 불리곤 한다.

각 서버는 호스트 서버에 있던 웹 컨텐츠(HTML 파일, 이미지, 오디오, 비디오, 애플리케이션 등) 일부의 복사본을 저장하거나 캐싱한다.

<br />

### CDN 사용의 장점

- **웹 퍼블리셔를 위한 연결 기능 및 확장성 강화**
  CDN은 이 컨텐츠와 사용자 간의 거리를 줄여 웹사이트 퍼블리셔가 성능을 향상하고 확장성을 강화할 수 있도록 한다.
- **CDN은 사이트 사용자의 컨텐츠 로딩 시간을 단축한다.**
  사용자가 경험하는 로딩 시간을 단축하고, 대역폭 소비 및 비용을 관리할 수 있게 한다.
- **대역폭 사용량 감축**
  웹 호스트는 원래 서버로부터 전송되는 데이터를 기준으로 요금을 부과한다. CDN은 사용자와 더 가까운 곳에 컨텐츠의 복사본을 저장함으로써 원래 서버로부터의 데이터 전송량을 줄인다. 그러면 기업의 대역폭 사용량 및 비용이 절약된다.
- **레이턴시 단축(latency)**
  시스템에 데이터를 요청하는 시점과 시스템에서 그에 응답하여 데이터를 보내기 시작하는 시점 사이의 지연 시간을 의미한다. 웹 컨텐츠를 요청하는 사용자와 이를 제공하는 서버 간의 거리가 길 수록 레이턴시가 늘어날 수 있다.
  CDN 서버는 사용자와 더 가까운 곳에 웹 컨텐츠를 저장하므로, 레이턴시를 단축하고 성능을 향상할 수 있다.
- **트래픽 급증에 더 효과적 대응**
  CDN에서는 로드 밸런싱을 사용하여 급증하는 수요를 여러 서버에 분산시킴으로써 하나의 서버에 과부하가 일어나는 것을 방지한다. 로드 밸런싱은 수요 급증이 웹사이트 성능에 영향을 미치는 것을 방지하는 효과도 있다.

<br />

### **CDN 작동 방식**

CDN은 웹사이트의 원래 서버와 달리 사용자에게 더 가까이에 있는 서버로부터 컨텐츠를 배포하는 방식으로, 웹 퍼블리셔가 더 빠르고 우수한 품질의 성능을 사용자에게 제공하도록 지원한다.

이를테면 웹사이트가 영국에 있다고 가정하자. 미국에 거주하는 누군가가 이 사이트에 엑세스할 경우, CDN은 영국에 있는 원래 서버가 아니라 미국에 있는 엣지 서버, 즉 사용자에게 더 가까운 서버에서 해당 웹 페이지를 서비스한다. 그러면 컨텐츠 로딩이 빨라지고 웹 애플리케이션 성능이 향상되며 결국 사용자 경험도 좋아진다.

전체 웹 트래픽의 절반 이상이 CDN을 통해 서비스되는 중이다.

기업에서 글로벌 거점을 확대하고 더 다양한 컨텐츠 유형을 제공함에 따라 이 비율은 계속 증가하고 있다. 게다가 CDN은 트래픽 로드를 분산시켜 어느 한 서버에 트래픽 요청이 집중되지 않게 한다. 게임 회사, 클라우드, 애플리케이션 개발자, 글로벌 시장을 대상으로 하는 전자 상거래 사이트 등으로 인해 디지털 소비 요구 사항이 증가함에 따라 컨텐츠 소유자는 사용자에게 더 좋은 서비스를 제공하고자 CDN을 활용한다.

<br />

## 소켓 프로그래밍

TCP 기반의 통신을 기반으로 한다.

UDP 기반의 소켓 통신은 서버가 패킷을 소켓에 제공하기 전에 패킷에 목적지 주소를 붙여야 한다.

하지만 TCP 기반의 소켓 통신은 TCP 연결을 설정한 후에 소켓을 통해 데이터를 TCP 연결로 보내기만 하면 된다.

<br />

### socket

클라이언트와 서버는 각각 socket을 생성한다.

<br />

### bind

서버가 특정 포트에 연결하겠다는 것을 의미한다.

서버쪽에선 포트를 고정시켜야 클라이언트가 접근할 수 있기 때문에 `bind` 시스템 콜을 호출한다.

클라이언트는 어느 포트에서든 시작할 수 있다,

<br />

### listen

클라이언트가 접속하길 기다린다.

여러 클라이언트로부터 요청을 받을 때를 대비해서 request buffer size를 둔다.

<br />

### accept

클라이언트의 요청이 올 때까지 block 된다.

<br />

### connect

클라이언트에서 서버에 연결할 때 사용하는 시스템 콜이다.

<br />

### read/write

소켓이 연결된 후에 메시지를 주고 받는 것은 `react/write` 를 통해서 통신한다.

<br />

### close

소켓에서 활용했던 리소스들을 release (자원 해제) 시킨다.
