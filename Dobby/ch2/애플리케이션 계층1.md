## 네트워크 애플리케이션 구조

애플리케이션 구조는 애플리케이션 개발자가 설계하며 선택한다.

<br />

### 클라이언트-서버 구조

서버가 클라이언트 호스트로부터 객체를 요청받으면 서버는 요청된 객체를 클라이언트 호스트로 보내면서 응답한다.

- 클라이언트-서버 구조에서 클라이언트는 서로 직접적으로 통신하지 않으며 서버를 통해 통신한다.
- 그렇기에 서버의 주소는 고정되어야 한다.
- 서버 주소가 고정되어야 클라이언트가 해당 주소로 찾아갈 수 있다.

<details>
<summary>💡 <span style="color:blue">데이터 센터</span></summary>
인기 있는 서비스의 경우 하나의 서버로만 요청을 처리하기엔 성능상의 문제가 발생할 수 있다.
그렇기에 많은 수의 호스트를 갖춘 데이터 센터가 가상의 서버를 생성하는 역할로 사용된다.

보통 하나의 데이터 센터는 전력이 공급되고 관리되어야 하는 10만 개 정도의 서버를 갖추고 있다.

</details>

<br />

### P2P 구조

서버에 최소로 의존한다.

대신, 애플리케이션은 피어(Peer)라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다.

피어(peer)는 사용자들이 제공하는 테스크톱과 랩톱 등에 해당하며, 특정 서버를 통하지 않고 피어가 통신하여 피어 투 피어 (peer-to-peer, P2P)라고 부른다.

<br />

- 자가 확장성이 있다.
  각 피어들은 자신이 가진 파일을 다른 피어들에게 분배함으로써 서버로의 역할을 수행할 수 있다.
- 비용 효율적이다.
  서버의 의존이 적기 때문에 서버 비용이 줄어든다.
- 분산 구조의 특성으로 인해 보안, 성능, 신뢰성 면에 문제가 있을 수 있다.

<br />

### 클라이언트와 서버 프로세스

네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성된다.

즉, 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신한다.

- 다른 프로세스와 세션을 시작하려고 접속하는 프로세스를 클라이언트라고 한다.
- 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.

<br />

## 소켓을 이용한 통신

컴퓨터끼리의 통신을 `네트워킹`이라고 한다.

이때 `소켓`을 이용해 통신이 이루어진다.<br />

- 네트워크에서 데이터를 보낸다는 것은 클라이언트 소켓이 서버 소켓에 데이터를 보내는 것이다.
- 소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스이다.

<br />

### 어플리케이션에서의 IP 주소

인터넷에서 IP의 역할은 목적지까지 데이터를 전송하는 것이며 이때 사용되는 주소가 IP 주소이다.

데이터는 IP 주소에 해당하는 컴퓨터에 도착한다.

<br />

### 어플리케이션에서의 포트 번호

IP로 도착한 해당 컴퓨터에는 네트워크를 사용하는 많은 수의 프로세스가 존재하며, 특정 프로세스를 구분할 주소가 필요하다. 이것이 포트(port) 번호이다.

즉, 포트 번호는 TCP가 네트워크를 사용하는 프로세스를 구분하기 위해 사용하는 주소이다.

<br />

## 애플리케이션이 이용 가능한 트랜스포트 서비스

소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스이다.

<br />

### 신뢰적 데이터 전송/비신뢰적 데이터 전송

송신 프로세스가 데이터를 소켓으로 보내고 그 데이터가 오류 없이 수신 프로세스에 도착할 수 있는가

<br />

### 처리율

대역폭 민감 애플리케이션들이 특정처리율 요구사항을 갖고 있는 반면, 탄력적 애플리케이션은 가용한 처리율이 많으면 많은 대로, 적으면 적은 대로 이용할 수 있다.
ex> 전자메일, 파일 전송, 웹 전송이 융통성 있는 App

<br />

### 시간과 보안

- 실시간 성이 요구되는 애플리케이션이 효과적으로 동작하기 위해서는 데이터 전송에 엄격한 시간 제한 조건이 요구된다.
- 송신 프로세스와 수신 프로세스 사이에서 데이터가 관찰 되더라도 기밀성을 보장한다.

<br />

## HTTP

HTTP는 TCP를 전송 프로토콜로 사용하며, 두 가지 프로그램으로 구현된다.<br />

- 클라이언트 프로그램
- 서버 프로그램

<br />

클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다.

- 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다.
- 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.

<br />

### 무상태

서버에서 클라이언트의 상태를 저장하지 않는 것을 의미한다.

클라이언트가 이전에 요청한 사항을 서버에 저장하지 않는다. 따라서 클라이언트는 요청에 필요한 데이터를 모두 가지고 있어야 한다. 또는 서버가 클라이언트로부터 받은 요청 사항을 모두 저장해야 한다.

<br />

### 비연결성

TCP/IP와는 달리 클라이언트에서 요청을 보낸 후 서버로부터 응답을 받으면 연결을 끊는 것을 의미한다.

비연결성은 불특정 다수를 대상으로 하는 서비스에 유리하다.

연결을 유지하지 않음으로써 자원을 아낄 수 있다.
하지만 연결을 유지하지 않기 때문에 서버가 클라이언트를 기억할 수 없다는 단점이 있다.

동일한 클라이언트에서 연속적으로 요청이 오면 연결과 연결 해제 과정을 반복하게 되어 자원을 낭비하게 된다.

이러한 단점을 보완하기 위해 일정 시간 동안 연결을 유지할 수 있도록 `HTTP Keep Alive`를 사용한다.

따라서 마지막 응답 이후 일정 시간 동안 연결을 유지해 동일한 클라이언트로부터 요청이 오면 연결 과정을 생략할 수 있다.

<br />

### HTTP 메시지 구조

![Alt text](image.png)

HTTP에서는 클라이언트와 서버가 통신하기 위해 정형화된 데이터인 `HTTP 메시지`를 주고받는다.

- 요청 라인(request line): 요청 URI, 요청 방법, HTTP 버전 등을 포함한다.
- 상태 라인(status line): 요청에 대한 HTTP 상태 코드와 HTTP 버전을 포함한다.
- 헤더(header): 키-값으로 구성된 다수의 헤더 항목으로 구성된다.
- 빈 줄(blank line): 헤더의 끝을 나타내는 빈 줄로, 헤더와 바디를 구분한다.
- 바디(body): 요청할 때 요청 방법 메서드가 POST인 경우에만 바디가 있고, 그 외 메서드일 때는 비어 있는 상태로 전달한다.

<br />

### HTTP 요청 메시지

```html
GET / index.html HTTP/1.1 Host: example.com Connection: close User-agent:
Mozilla/5.0 Accept-language: ko
```

- Host: 객체가 존재하는 호스트 명시
- Connection: 지속 연결에 대한 요청 (close→지속 연결 원하지 않음)
- User-agent: 서버에게 요청하는 브라우저 타입
- Accept-language: 사용자가 원하는 언어

<br />

### HTTP 응답 메시지

```html
HTTP/1.1 200 OK Content-Type: text/html Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS) Cache-Control: max-age=3600 Last-Modified: Sat, 03
Sep 2022 00:00:00 GMT Content-Length: 157 Connection: close

<!DOCTYPE html>
<html>
  ...
</html>
```

- Connection: 지속 연결에 대한 응답
- Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간
- Server: 어떤 웹 서버를 사용하는지
- Last-Modified: 객체가 생성되거나 마지막으로 수정된 날짜와 시간
- Content-Length: 송신되는 객체의 바이트 수
- Content-Type: 송신되는 객체의 유형

<br />

### HTTP 상태 코드

클라이언트의 요청에 대한 서버의 상태를 알려 주는 코드

1xx: 클라이언트로부터 요청을 받아 처리 중

3xx: 요청을 처리하기 위해 추가 처리 필요

| 상태 코드 | 의미                                   | 분류            |
| --------- | -------------------------------------- | --------------- |
| 200       | 클라이언트 요청을 성공적으로 처리함    | 요청 성공       |
| 401       | 인증되지 않음                          | 클라이언트 오류 |
| 403       | 접근 실패                              | 클라이언트 오류 |
| 404       | 클라이언트에서 요청한 자원을 찾지 못함 | 클라이언트 오류 |
| 500       | 서버 내부 오류 발생                    | 서버 오류       |

<br />

## 쿠키

서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로 웹사이트가 사용자를 확인하는 것이 바람직할 때가 있다.

이 목적으로 HTTP는 쿠키를 사용한다.

<details>
<summary>✅ <span style="color:blue">쿠키</span></summary>
HTTP의 일종으로 사용자가 웹 사이트를 방문할 경우,
그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.
HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있다.

</details>

<br />

### 동작 순서

1. 클라이언트가 페이지를 요청한다. (사용자가 웹 사이트에 접근)
2. 웹 서버는 쿠키를 생성한다.
3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.
4. 넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할 때 함께 쿠키를 전송한다.
5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송한다.

<br />

HTTP 응답 메시지를 받았을 때 쿠키 설정은 `Set-Cookie:` 헤더를 통해 볼 수 있다.

HTTP 요청 메시지를 받았을 때 쿠키 설정은 `Cookie:` 헤더를 통해 볼 수 있다.

쿠키는 사용자 식별에 사용할 수 있으며 무상태 HTTP 위에서 사용자 세션 계층을 생성하는 데 이용될 수 있다.

<br />

## 웹 캐싱

웹 캐시 (proxy server)는 origin web server를 대신하여 HTTP 요청에 응답하는 네트워크 개체다.

proxy는 자체 저장디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.

즉, 브라우저는 사용자의 모든 HTTP 요청을 proxy에 가장 먼저 보내지도록 구성할 수 있다.

<br />

### 웹 캐시의 장점

- 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
- 한 기관에서 인터넷으로의 접속 트래픽을 대폭 줄일 수 있다.

<br />

### 동작 과정

1. 브라우저는 proxy와 TCP 연결을 설정하고 proxy server에 있는 객체에 대한 HTTP 요청을 보낸다.
2. proxy는 객체의 사본이 자신에게 저장되어 있는지 확인하고, 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 만약 proxy가 객체를 갖고 있지 않다면, proxy는 origin server에 TCP 연결을 설정한다.
   이후 proxy는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다.
   이러한 요청을 받은 후에 origin server는 proxy로 HTTP 응답 메시지와 함께 객체를 보낸다.
4. proxy는 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

위의 동작 과정을 통해 proxy server는 서버이면서 클라이언트라는 점을 유의해야 한다.

또한 일반적으로 Proxy는 ISP가 구입하고 설치하며 CDN의 사용을 통해 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다.

<details>
<summary>💡 <span style="color:blue">CDN (Content Delivery Network)</span></summary>

지리적으로 분산된 서버들을 연결한 네트워크로서 웹 컨텐츠의 복사본을 사용자에 가까운 곳에 두거나 동적 컨텐츠의 전달을 활성화하여 웹 성능 및 속도를 향상할 수 있게 한다.
즉, 지역적으로 분산된 캐시를 설치하고 트래픽을 지역화하는 것이다.

</details>

<br/>

### 캐시 유효성 검증 및 조건부 요청

캐시의 유효 기간이 지난 다음 다시 서버에 리소스를 요청하면 둘 중 하나일 것이다.

이전과 다르지 않은 데이터를 그대로 받거나, 새롭게 갱신된 데이터를 받거나.

이때, 전자의 경우에는 의미 없는 트래픽을 낭비한 것이된다.

이런 트래픽 낭비를 줄이기 위해, 실제 원본 데이터가 수정 되었을 때만 리소스를 내려 받는 것이 바람직하다.

이런 과정을 `캐시 유효성 검증(validation)` 및 `조건부 요청(conditional request)`라고 한다.

이 방식은 크게 2가지로 나뉜다.

첫 번째로는 리소스의 마지막 갱신 시각으로 검증하는 `Last-Modified`와 `If-Modified-Since` 를 사용하는 방법, 두 번째로는 리소스의 식별자를 기준으로 검증하는 `ETag` 와 `If-None-Match` 를 사용하는 방법이다.

<br />

### Last-Modified/If-Modified-Since

최초 요청 시 응답

```html
HTTP/1.1 200 OK Content-Type: text/html Cache-Control: max-age=3600
Last-Modified: Sat, 03 Sep 2022 00:00:00 GMT Content-Length: 157

<!DOCTYPE html>
<html>
  ...
</html>
```

아까와 동일한 응답이다. 단, 여기에 **`Last-Modified`** 라는 헤더가 추가되었다. 이 헤더에는 요청한 리소스가 마지막으로 수정된 일자를 나타낸다. 브라우저는 이 **`Last-Modified`** 를 저장해둔다.

<br />

두번째 요청

```html
GET /index.html HTTP/1.1 Host: example.com Accept: text/html If-Modified-Since:
Sat, 03 Sep 2022 00:00:00 GMT
```

이후 캐시 기간이 초과되어 두번째 요청 시 브라우저는 저장해둔 **`Last-Modified`** 값을 **`If-Modified-Since`** 라는 요청 헤더에 넣어 서버로 요청을 보낸다.

<br />

리소스가 변경되지 않았을 경우

```html
HTTP/1.1 200 OK Content-Type: text/html Cache-Control: max-age=3600
Last-Modified: Sat, 03 Sep 2022 00:00:00 GMT Content-Length: 157

<!DOCTYPE html>
<html>
  ...
</html>
```

만약 위와 같이 조건부 요청을 보냈는데, 원본 리소스에 아무런 변경이 없었다면, 서버는 위와 같이 **`304 Not Modified`** 라는 상태 코드로 응답한다. 또한 이 응답에는 Response Body가 없기 때문에 트래픽을 아낄 수 있다.

<br />

### ETag/If-None-Match

앞서 소개한 방법은 밀리 세컨드 단위로 시각을 설정할 수 없다는 한계점이 존재한다. ETag란 특정 버전의 리소스를 식별하기 위해 사용하는 식별자이다.

이를 통해 `Last-Modified` / `If-Modified-Since` 의 단점을 극복할 수 있다.

최초 요청 시 응답

```html
HTTP/1.1 200 OK Content-Type: text/html Cache-Control: max-age=3600 ETag:
"abcdefg" Content-Length: 157

<!DOCTYPE html>
<html>
  ...
</html>
```

리소스에 대한 최초 요청 시 **`ETag`** 라는 응답 헤더가 돌아온다. 요청한 리소스의 현재 버전에 대한 식별자이다. 브라우저는 이 **`ETag`** 값을 저장한다.

<br />

두번째 요청

```html
GET /index.html HTTP/1.1 Host: example.com Accept: text/html If-None-Match:
"abcdefg"
```

이후 캐시 기간이 초과되어 리소스에 대해 재요청시 **`If-None-Match`** 라는 헤더에 저장해둔 **`ETag`** 값을 넣어서 보낸다.

<br />

```html
HTTP/1.1 304 Not Modified Content-Type: text/html Cache-Control: max-age=3600
Last-Modified: "abcdefg"
```

마찬가지로 리소스가 변경되지 않은 경우 서버는 Response Body를 제외하고, **`304 Not Modified`** 로 응답한다.

<br />

### no-cache, no-store

유저에게 항상 최신 버전의 리소스만을 제공하고 싶을 경우가 있을 것이다. 이때, 항상 최신 버전의 리소스를 캐시하거나, 혹은 아예 캐시 자체를 하지 않는 방법이 있다.

이런 옵션을 위해서 웹 브라우저가 요청을 보낼 때 **`Cache-Control`** 헤더에 **`no-cache`** 혹은 **`no-store`** 디렉티브를 포함할 수 있다.

> Cache-Control 은 요청과 응답 양쪽에서 사용되는 헤더이다.

<br />

### no-cache

이름 때문에 헷갈리지 말자. **`no-cache`** 는 캐시를 아예 생성하지 않는 옵션이 **아니다**. **리소스에 대한 캐시를 생성하지만, 리소스를 요청할 때 원 서버에 항상 캐시 유효성 검증**을 하는 옵션이다.

<br />

### no-store

**`no-store`** 는 리소스에 대한 캐시를 생성하지 말라는 가장 강력한 **`Cache-Control`** 디렉티브이다. 저장하면 안되는 민감한 정보일 때 사용한다.

<br />

## private vs public

**`Cache-Control`** 헤더의 **`private`** 또는 **`public`** 디렉티브를 사용하여 캐시 허용 범위를 지정할 수 있다.

**`public`** 디렉티브를 사용하면 Shared Cache (proxy) 에서도 캐싱을 허용하고, **`private`** 디렉티브를 사용하면 사용자 브라우저에게만 캐싱을 허용한다.

```
Cache-Control: max-age=3600, private;
```

기존 디렉티브와 함께 사용하려면 위와 같이 **`,`** 로 구분한다.

<br />

### **HTTP/1.1, HTTP/2, HTTP/3 각각의 특징**

HTTP/1.1은 오늘날까지 널리 사용되는 버전으로 이전 버전과 달리 지속 연결이 공식적으로 지원되었으며, 파이프라이닝 기능도 추가되었다.

HTTP/2는 HTTP/1.1의 효율과 성능을 높이기 위한 버전이다.

송수신 효율을 높이기 위해 헤더를 압축하여 전송하고, 바이너리 데이터 기반의 메시지를 송수신한다.

또한 서버 푸시 기능을 제공하기도 합니다.

HTTP/3은 이전 버전들이 TCP 기반으로 동작했다면 3버전은 UDP 기반으로 동작한다.

연결형 프로토콜인 TCP에 비해 비연결형 프로토콜인 UDP는 상대적으로 더 빠르기 때문에, HTTP/3은 속도 측면에서 큰 개선이 이루어졌다.

<br />

## 인터넷 전자메일

전자메일은 비동기적인 통신 매체다.

일반 메시지는 송신자의 사용자 에이전트에서 전달이 시작되고, 송신자의 메일 서버를 거친 후에 수신자의 메일 서버로 전달된다.

거기서 수신자의 메일박스에 저장된다.

STMP는 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜이다.

SMTP는 메일을 송신자의 메일 서버로부터 수신자의 메일 서버로 전송하는데 TCP의 신뢰적인 데이터 전송 서비스를 이용한다.

메일 서버가 상대 메일 서버로 메일을 보낼 때는 SMTP의 클라이언트로 동작하는 반면, 메일 서버가 상대 메일 서버로부터 메일을 받을 때는 SMTP 서버로 동작한다.

또한 SMTP는 TCP 지속 연결을 사용한다.

SMTP는 메일을 보낼 때 두 메일 서버가 먼 거리에 떨어져 있더라도 중간 메일 서버를 사용하지 않는다.

수신자의 메일 서버가 죽어 있다면 메시지는 어느 중간 메일 서버에 저장되는 것이 아니라 송신자의 메일 서버에 남아 새로운 시도를 기다린다.

<br />

### 동작 과정

1. 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP 연결을 설정한다.
2. 만약 서버가 죽어 있으면 클라이언트는 나중에 다시 시도한다.
3. 연결이 설정되면, 서버와 클라이언트는 애플리케이션 계층 핸드셰이킹을 수행하고 송수신자의 전자메일 주소를 제공한다.
4. SMTP 클라이언트와 서버가 서로에 대한 소개를 마치면, 클라이언트는 메시지를 보낸다.
5. 서버에 보낼 다른 메시지가 있으면, 클라이언트는 이 과정을 같은 TCP 연결상에서 반복한다.
6. 보낼 메시지가 없으면 TCP에게 연결을 닫을 것을 명령한다.

<br />

<details>
<summary>💡 IMAP</summary>
Internet Mail Access Protocol, 인터넷 메일 접근 프로토콜
메일 서버로부터 자신의 전자메일을 확인하는 방법은 SMTP가 아닌 HTTP 혹은 메일 클라이언트인 IMAP을 사용하는 것이다.
HTTP나 IMAP 모두 메일 서버에 의해 유지되는 폴더를 관리하게 된다.
자신의 메시지를 자신이 생성한 폴더로 이동, 삭제하거나 중요 메시지로 표기해둘 수 있다.

</details>

수신자가 사용자 에이전트로부터 메시지를 얻기 위해 SMTP를 사용할 수 없는데, 이는 SMTP가 푸시(Push) 프로토콜인 반면에 메시지를 얻는 것은 풀(pull) 동작이기 때문이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/c2d7071a-d021-41a0-bfec-603e74a1b713/Untitled.png)

<br />

### 메시지 포맷

```
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
```

위의 메시지 헤더 다음에 빈 줄이 이어지고, 그 다음에 메시지 몸체(ASCII 문자)가 나온다.
