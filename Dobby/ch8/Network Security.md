## 네트워크 보안

- 기밀성
  - 송신자와 지정된 수신자만이 전송되는 메시지 내용을 이해할 수 있어야 한다.
- 메시지 무결성
  - 신뢰적인 전송 및 데이터 링크 프로토콜을 위해 사용했던 체크섬 기술을 확장함으로써 메시지 무결성을 제공할 수 있다.
- 종단점 인증
  - 송신자와 수신자는 통신에 참여하는 상대방이 실제 누구인지 확인하기 위해 상대방의 신원을 확인할 수 있어야 한다.
- 운영 보안
  - 방화벽은 기관 네트워크와 공공 네트워크 사이에 설치되어 두 네트워크 사이를 오가는 패킷들을 제어한다.
  - 침입 감지 시스템은 패킷을 상세히 관찰하고 의심스러운 행위에 대해 네트워크 관리자에게 보고한다.

<br />

## 암호화

암호 기술은 송신자가 데이터를 변형시켜서 침입자가 가로챈 데이터로부터 아무런 정보도 얻지 못하도록 하기 위한 것이다.

물론, 수신자는 변형된 데이터로부터 원래 데이터를 복원해낼 수 있어야 한다.

- 대칭키 시스템
  - 송신자와 수신자의 키가 동일하고 이 키는 둘만 알고 있어야 한다.
- 공개키 시스템
  - 한 쌍의 키가 사용된다. (공개키, 개인키)

<br />

### 대칭키 암호화

암복호화키가 동일하며 해당 키를 아는 사람만이 문서를 복호화해 볼 수 있게 된다.

공개키 암호화 방식에 비해 속도가 빠르다는 장점이 있지만, 키를 교환해야 한다는 문제(키 배송 문제)가 발생한다.

키를 교환하는 중 키가 탈취될 수 있는 문제도 있고 사람이 증가할수록 전부 따로따로 키 교환을 해야하기 때문에 관리해야 할 키가 방대하게 많아진다.

이러한 키 배송 문제를 해결하기 위한 방법으로 키의 사전 공유에 의한 해결, 키 배포센터에 의한 해결, 공개키 암호화에 의한 해결이 있다.

![image](https://github.com/user-attachments/assets/869b4e86-997a-4157-91b6-650011c36b14)

<br />

### 공개키 암호화

대칭키의 키교환 문제를 해결하기 위해 등장한 것이 공개키(비대칭키) 암호화 방식이다.

이름 그대로 키가 공개되어 있기 때문에 키를 교환할 필요가 없어지며 공개키는 모든 사람이 접근 가능하고 개인키는 각 사용자만이 가지고 있는 키이다.

![image](https://github.com/user-attachments/assets/e3508d66-f9e6-4e36-b762-a920f5253670)

1. B 공개키/개인키 쌍 생성
2. 공개키 공개(등록), 개인키는 본인이 소유
3. A가 B의 공개키를 받아옴
4. A가 B의 공개키를 사용해 데이터를 암호화
5. 암호화된 데이터를 B에게 전송
6. B는 암호화된 데이터를 B의 개인키로 복호화 (개인키는 B만 가지고 있기 때문에 B만 볼 수 있음)

공개키는 키가 공개되어 있기 때문에 따로 키 교환이나 분배를 할 필요가 없어진다.

중간 공격자가 B의 공개키를 얻는다고 해도 B의 개인키로만 복호화가 가능하기 때문에 기밀성을 제공하며 개인키를 가지고 있는 수신자만이 암호화된 데이터를 복호화할 수 있으므로 일종의 인증기능도 제공한다는 장점이 있다.

그에 반해 단점은 속도가 느리다는 것이다.

그래서 처음에 공개키 암호화로 세션 키를 교환하고, 해당 키로 대칭키 암호화를 진행한다.

<br />

## 메시지 무결성과 전자서명

링크 상태 알고리즘에서 각 라우터는 네트워크 내의 다른 라우터에게 링크 상태 메시지를 보내야 한다.

라우터의 링크 상태 메시지는 직접적으로 연결된 이웃들의 목록과 이 이웃들의 연결 비용을 포함하고 있다.

일단 한 라우터가 다른 모든 라우터로부터 링크 상태 메시지를 받으면 네트워크 전체 지도를 생성해낼 수 있고, 최소 비용 라우팅 알고리즘을 수행하여 포워딩 테이블을 설정할 수 있다.

침임자 트루디가 라우팅 알고리즘에 행할 수 있는 비교적 단순한 공격은 잘못된 링크 상태 정보를 담은 가짜 링크 상태 메시지르르 배포하는 것이다.

따라서, 메시지 무결성이 필요하다.

<br />

### 암호화 해시 함수

암호화 해시 함수는 디지털 서명, 메시지 인증 코드(MAC) 및 기타 인증 형식을 포함한 다양한 암호화 응용 프로그램에 사용되도록 설계된 특수한 유형의 해시 함수이다.

암호화 해시 함수는 다른 해시 함수와 구별되는 몇 가지 필수 속성을 가지고 있다.

1. 결정론: 동일한 입력 메시지는 항상 동일한 해시 값을 생성한다.
2. 효율성: 입력 크기에 관계없이 해시 값이 빠르게 계산된다.
3. 충돌 저항: 동일한 해시 값을 생성하는 두 개의 서로 다른 메시지를 찾는 것은 계산상 불가능하다.
4. 이미지 저항: 해시 값이 주어지면 해당 특정 해시를 생성하는 메시지를 생성하는 것이 불가능하다.
5. 눈사태 효과: 입력 메시지의 작은 변경으로 인해 출력 해시에 상관 관계가 없어 보이는 중요한 변경이 발생한다.

[ **일반적인 암호화 해시 함수** ]

- MD5: 한때 인기가 있었지만 이제는 암호화되어 있어 보안 애플리케이션에 적합하지 않은 것으로 간주된다.
- SHA-1: 이전에는 널리 사용되었지만, 현재는 보안 취약성으로 인해 더 이상 사용되지 않는다.
- SHA-2: SHA-256은 현재 가장 일반적으로 사용되는 변종이다.
- SHA-3: 특정 유형의 공격에 대한 저항력을 더욱 강화하도록 설계된 보안 해시 알고리즘 제품군의 최신 구성원이다.

[ **암호화 해시 함수의 응용** ]

- 디지털 서명: 메시지의 고정 크기 다이제스트를 생성하는 데 사용되며, 이 다이제스트는 보낸 사람의 개인 키로 암호화된다.
- 파일 무결성 확인: 웹사이트에서는 다운로드 가능한 파일에 대한 해시 값을 게시하여 사용자가 다운로드 후 파일의 무결성을 확인할 수 있는 경우가 많다.
- 비밀 번호 보안: 비밀번호는 일반적으로 일반 텍스트가 아닌 해시로 저장되어 보안이 강화된다.
- Blockchaing 기술: 비트코인과 같은 암호화폐는 암호화 해시 기능(예: SHA-256)을 사용하여 거래 기록의 무결성과 보안을 유지한다.
- SSL/TLS 프로토콜

<br />

### 메시지 인증 코드

1. 앨리스는 메시지 m을 생성하고 해시 H(m)을 계산한다.
2. 앨리스는 메시지 m에 H(m)을 첨부하여 확장 메시지 (m, H(m))을 생성한 후 밥에게 보낸다.
3. 확장 메시지 (m, h)를 받은 밥은 H(m)을 계산한다. 만일 H(m) = h라면, 밥은 모든 것이 문제없이 처리되었다고 결론지을 수 있다.

위의 방법은 트루디가 가짜 메시지 m’을 생성하여 메시지 내에서 자신이 앨리스라고 주장한 후, H(m’)을 생성하여 밥에게 (m’, H(m’))을 보낼 수 있다.

위와 같은 상황을 위해 메시지 무결성이 필요하며, 메시지 무결성은 암호화 해시 함수의 사용 외에도 앨리스와 밥이 비밀키 s를 공유할 필요가 있다.

1. 앨리스는 메시지 m을 생성한 후 s와 접합하여 m + s를 만든다. 그런 다음 해시 H(m + s)를 계산해내는데, 이것을 메시지 인증 코드(MAC)이라고 부른다.
2. 앨리스는 MAC으르 메시지 m에 첨부하여 확장 메시지 (m, H(m + s))를 생성해서 밥에게 보낸다.
3. 밥은 확장 메시지 (m, h)를 받으면 이미 알고 있는 s를 이용하여 MAC H(m + s)를 계산한다. 만일 H(m + s) = h라면, 밥은 아무 문제가 없다고 결론짓는다.

- 여기서 MAC은 링크 계층 프로토콜의 MAC과 같지 않다.

MAC의 유용한 특성 중 하나는 암호화 알고리즘을 필요로 하지 않는다는 점이다.

[ **공유 인증키 s를 통신 개체들에게 배포하는 방법** ]

각각의 라우터가 자신만의 공개키를 갖고 있다면, 인증키는 각 라우터의 공개키로 암호화되어 네트워크를 통해 전달될 수 있다.

<br />

### 전자서명

전자서명은 디지털 세계에서 메시지 무결성과 사용자 인증을 위해 사용되는 암호화 기법이다.

손으로 한 서명처럼 전자서명은 서명자를 입증할 수 있어야 하고, 위조할 수 없도록 해야 한다.

밥이 메시지에 서명할 때 밥은 자신의 고유한 무엇인가를 메시지에 포함시켜야 한다.

자신의 고유 비밀키를 메시지에 첨부하고 이를 해시 함수에 넣어서 만들어진 MAC을 서명으로 쓰는 방법을 고려해볼 수 있다.

→ 자신의 개인키로 메시지를 암호화하고, 수신자는 송신자의 공개키로 메시지를 복호화함으로써 사용자 인증 및 무결성을 보장할 수 있다.

우리는 전자서명이 수신자에게 송신자의 신분뿐만 아니라 메시지 자체가 변형되지 않았음을 확인할 수 있게 함으로써 메시지 무결성을 제공한다는 사실을 알 수 있다.

암호화 기술을 이용한 전자서명의 한 가지 문제점은 암호화와 복호화를 위한 연산이 과중하다는 것이다.

좀 더 효율적인 방법은 해시 함수를 전자서명에 이용하는 것이다.

해시 알고리즘은 임의 길이의 메시지 m을 가지고 H(m)으로 표현되는 고정 길이의 ‘지문’을 계산해낸다.

해시 함수를 수행한 후에 밥은 메시지 자체가 아니라 메시지의 해시 결과에 서명한다.

일반적으로 H(m)은 원래 메시지 m보다 훨씬 짧으므로, 전자서명을 생성하기 위한 연산 작업의 부하가 훨씬 줄어든다.

[ **밥이 앨리스에게 메시지를 보내는 상황** ]

1. 밥은 원래의 긴 메시지에 해시 함수를 적용한 후, 해시 결과에 그의 개인키로 전자서명을 한다.
2. 전자적으로 서명된 메시지 요약문과 함께 원래 메시지(평문)이 앨리스에게 전달된다.
3. 앨리스는 송신자의 공개키를 메시지에 적용해서 해시 결과를 얻는다.
4. 해시 함수를 평문에 적용해서 두 번째 해시 결과를 얻는다.
5. 이 두 해시값이 일치하다면, 앨리스는 메시지의 무결성과 작성자의 진위에 대해 확신할 수 있다.

<br />

### 공개키 인증

공개키 인증은 IPsec과 TLS를 포함한 많은 대중적인 보안 네트워킹 프로토콜에서 사용된다.

공개키가 어떤 특정한 통신 개체의 것인지 보증하는 일은 일반적으로 인증기관(CA)에서 담당하는데, 이들이 하는 일은 신원을 확인하고 인증서를 발행하는 것이다,

[ **CA의 역할** ]

- 어떤 개체(사람, 라우터 등)가 스스로 주장하는 자신의 신분, 바로 그 개체가 맞는지 확인한다.
- 일단 CA가 개체의 신원을 확인하면, CA는 그 개체의 공개키와 신분 확인서를 결합한 인증서를 만든다.
- 이 인증서는 공개키와 함께 이 공개키의 주인에 대한 고유한 식별 정보를 담고 있다.
- 인증서에는 CA가 전자서명을 한다.

밥이 CA가 서명한 그의 인증서를 앨리스에게 보낸다.

앨리스는 CA의 공개키를 사용하여 밥의 인증서의 유효성을 검사하고, 밥의 공개키를 뽑아낸다.

<br />

## 종단점 인증

종단점 인증이란 하나의 통신 개체가 다른 개체에게 자신의 신원을 컴퓨터 네트워크상으로 증명하는 작업이다.

인증은 인증 프로토콜의 한 부분으로서 교환된 메시지와 데이터만을 기반으로 수행되어야 한다.

대개 인증 프로토콜은 두 통신 관계자가 어떤 다른 프로토콜을 수행하기 이전에 수행된다.

인증 프로토콜은 먼저 서로의 요구에 맞춰 통신 당사자들의 신원을 확인한다.

인증 후에야 통신 당사자들은 실제 작업을 시작할 수 있다.

<br />

### 인증 프로토콜 ap4.0

넌스(nonce)는 프로토콜이 평생에 단 한 번만 사용하는 숫자를 뜻한다.

즉, 프로토콜이 한 번 어떤 넌스를 사용하면 이 숫자를 절대로 다시 사용하지 않는다.

프로토콜 ap4.0은 넌스를 다음과 같이 사용한다.

1. 앨리스는 메시지 “나는 앨리스다”를 밥에게 보낸다.
2. 밥은 넌스 R을 선택하고 그것을 앨리스에게 보낸다.
3. 앨리스는 앨리스와 밥의 대칭 비밀키를 사용해서 그 넌스를 암호화하고, 암호화된 넌스를 밥에게 보낸다. 상대방이 대칭 비밀키를 알고 있고 이것을 암호화에 사용했으므로 밥은 자신이 받은 메시지를 앨리스가 만들었다는 사실을 알게 된다. 앨리스가 현재 실제 통신 중임을 확인하기 위해 넌스가 사용된다.
4. 밥은 자신이 받은 메시지를 복호화한다. 만약 복호화한 넌스가 자신이 앨리스에게 보낸 것과 같다면 앨리스를 인증한다.

일회용인 R을 사용하고 반환되는 값(암호화된 R)을 확인함으로써 밥은 스스로 앨리스라고 주장하는 사람이 진짜 앨리스라는 것(R의 암호화에 필요한 비밀키를 알고 있기 때문에)과 실제로 현재 통신 중이라는 것 두 가지를 확신할 수 있다.

<br />

## 전자메일 보안

왜 보안 기능이 인터넷의 하나 이상의 계층에서 제공될까?

1. 네트워크 계층에서 데이터그램의 모든 데이터를 암호화하고 모든 출발지 IP 주소를 인증함으로써 ‘전면적 범위’의 보안을 제공하더라도 사용자 레벨의 보안은 제공할 수 없다.
2. 프로토콜 스택의 상위 계층에서 보안 서비스를 포함한 새로운 인터넷 서비스를 구현하는 일이 점차 쉬워지고 있다.

<br />

### 보안 전자메일

보안의 특성에는 다음과 같이 3가지가 있다.

1. 기밀성
2. 메시지 무결성
3. 수신자 인증

<br />

[ 기밀성 ]

기밀성을 제공하는 가장 직접적인 방법은 대칭키/공개키 암호화(RSA)를 사용하는 것이다.

하지만 공개키 암호화가 상대적으로, 특히 길이가 긴 메시지에 대해 비효율적이라는 문제가 있다.

이 비효율성 문제를 극복하기 위해 세션키를 이용한다.

1. 앨리스는 임의의 대칭 세션키 Ks를 선택하여
2. 그 대칭키로 메시지 m을 암호화하고
3. 그 대칭키는 밥의 공개키 Kb로 암호화한 후
4. 암호화된 메시지와 암호화된 대칭키가 한 ‘꾸러미’가 되도록 이어 붙여
5. 그 꾸러미를 밥의 전자메일 주소로 보낸다.

밥이 꾸러미를 받으면,

1. 그의 개인키 Kb를 사용해 대칭키 Ks를 얻고
2. 대칭키 Ks로 메시지 m을 복호화한다.

<br />

[ 수신자 인증, 메시지 무결성 ]

1. 앨리스는 메시지 요약문을 얻기 위해 자신의 메시지 m에 해시 함수 H를 적용하고
2. 전자서명을 만들기 위해 해시 함수의 결과를 그녀의 개인키 Ka로 암호화한 후
3. 원래의 메시지와 서명을 결합하여 꾸러미를 만들고
4. 이 꾸러미를 밥의 전자메일 주소로 보낸다.

밥이 꾸러미를 받으면,

1. 서명된 메시지 요약문에 앨리스의 공개키 Ka를 적용하고
2. 이 연산의 결과를 자신이 직접 해시 함수 H를 메시지에 적용한 결과와 비교한다.

만일 두 결과가 같으면, 밥은 그 메시지는 앨리스가 보냈으며 변경되지 않았음을 거의 확신해도 좋다.

<br />

## TCP 연결의 보안: TLS

애플리케이션 계층에 속하는 보안 계층

암호학이 기밀성, 데이터 무결성, 종단점 인증 등의 보안 서비스를 이용하여 어떻게 TCP를 향상할 수 있을까?

이렇게 향상된 TCP 버전을 흔히 TSL(Transport Layer Security)라고 부른다.

URL이 http가 아닌 https:로 시작한다면, 브라우저가 TLS를 사용하고 있는 것이다.

TLS는 기밀성, 데이터 무결성, 서버 인증과 클라이언트 인증을 통해 TCP를 향상함으로써 여러 보안 문제를 해결한다.

TLS는 종종 HTTP상에서 행해지는 거래에 보안을 제공하기 위해 사용된다.

<img src="https://github.com/user-attachments/assets/3f32ab0b-4f5c-4c3e-aaa7-0b70ea645721" width="60%" />

TLS는 TCP를 보호하기 때문에 TCP상에서 일어나는 어떠한 애플리케이션에든 사용될 수 있다.

TLS는 소켓을 사용하는 간단한 API를 제공하는데, 이는 TCP의 API와 유사하다.

<br />

### 핸드셰이크

핸드셰이크 단계에서 밥은 앨리스와 TCP연결을 설립하고,

그 앨리스가 진짜 앨리스인지 확인하며,

TLS 세션에 필요한 모든 대칭키를 생성하기 위해 앨리스와 밥이 사용할 주 비밀키를 앨리스에게 전송한다.

1. 밥은 앨리스에게 Hello 메시지를 보낸다.
2. 앨리스는 그녀의 공개키를 담은 인증서로 응답한다.
3. 밥은 MS(Master secret)을 생성하고, 이를 앨리스의 공개키로 암호화하여 EMS(Encrypted Master Secret)를 만든다.
4. 이 EMS가 앨리스에게 전송되고 앨리스는 자신의 개인키를 가지고 EMS를 복호화함으로써 결국 MS를 얻는다.
5. 앨리스와 밥은 MS로부터 각자 4개의 키를 생성한다.
6. 2개의 암호화 키는 데이터를 암호화하는 데 쓰이고, 2개의 HMAC 키는 데이터 무결성을 확인하는 데 사용될 것이다.

원칙적으로 밥과 앨리스가 공유한 MS는 이후에 모든 암호화와 데이터 무결성 검사를 위한 대칭 세션키로 사용될 수 있다.

그러나 일반적으로 앨리스와 밥이 각각 다른 암호화 키를 사용하고, 암호화와 무결성 검사에도 서로 다른 키를 사용하는 것이 좀 더 안전하다.

따라서 앨리스와 밥은 MS를 이용하여 4개의 키를 생성한다.

1. Eb = 밥이 앨리스에게 보내는 데이터에 대한 세션 암호화 키
2. Mb = 밥이 앨리스에게 보내는 데이터에 대한 세션 HMAC 키, 여기서 HMAC은 표준화된 해시 메시지 인증 코드를 의미한다.
3. Ea = 앨리스가 밥에게 보내는 데이터에 대한 세션 암호화 키
4. Ma = 앨리스가 밥에게 보내는 데이터에 대한 세션 HMAC 키

<br />

### 데이터 전송

1. TLS는 데이터 스트림을 레코드로 쪼개고,
2. HMAC을 생성하기 위해 밥은 레코드 데이터와 키 Mb, 현재 순서 번호를 해시 함수에 넣는다.
3. 각 레코드에 무결성 검사를 위한 HMAC을 덧붙인 후 이 ‘ `레코드 + HMAC` ’을 암호화한다.
4. `레코드 + HMAC` 꾸러미를 암호화하기 위해 밥은 그의 세션 암호화 키 Eb를 사용한다.
5. 이렇게 암호화된 꾸러미는 인터넷상으로 전송하기 위해 TCP로 보내진다.

앨리스는 밥의 순서 번호를 추적해서 자신이 HMAC을 계산할 때 적적할 순서 번호를 포함시킴으로써 레코드의 데이터 무결성을 확인할 수 있다.

TLS 순서 번호의 이러한 사용은 트루디가 중간자 공격을 수행하여 세그먼트의 순서를 바꾸거나 재생하지 못하게 한다.

<br />

### TLS 레코드 포맷

<img src="https://github.com/user-attachments/assets/a19b495d-933f-4c0e-82f3-66ec12b35866" width="60%" />

타입, 버전, 길이, 데이터, HMAC 필드로 TLS 레코드는 이루어져 있다.

처음 세 필드는 암호화되지 않는다.

- 타입 필드는 레코드가 핸드셰이크 메시지인지 애플리케이션 데이터를 담은 메시지인지 나타낸다.

<br />

### TLS 핸드셰이크

실제 TLS 핸드셰이크 과정은 다음과 같다.

1. 클라이언트는 넌스와 함께 자신이 지원하는 암호화 알고리즘의 목록을 보낸다.
2. 목록으로부터 서버는 대칭키 알고리즘, 공개키 알고리즘, HMAC 키와 함께 HMAC 알고리즘을 선택하여 자신의 선택 결과와 인증서, 서버 넌스를 클라이언트에게 돌려준다.
3. 클라이언트는 인증서를 확인하고 서버의 공개키를 알아낸 후 PMS(Pre-Master Secret)을 생성한다. 이 PMS를 서버의 공개키로 암호화한 후 서버에게 보낸다.
4. 클라이언트와 서버는 같은 키 유도 함수를 사용하여 PMS와 넌스로부터 독립적으로 MS를 계산한다. 이후 MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할된다.
5. 이후부터 클라이언트와 서버 간 모든 메시지는 암호화되고 인증된다 (HMAC을 이용하여)
6. 클라이언트는 모든 핸드셰이크 메시지의 HMAC을 전송한다.
7. 서버는 모든 핸드셰이크 메시지의 HMAC을 전송한다.

마지막 두 단계는 핸드셰이크가 훼손되는 것을 방지한다.

훼손 공격을 막기 위해 5단계에서 클라이언트는 주고받은 모든 핸드셰이크 메시지를 연결한 후 이에 대한 HMAC을 전송한다.

서버는 이 MAC을 모든 핸드셰이크 메시지에 대해 자신이 만든 HMAC과 비교한다.

어떤 불일치가 발견되면, 서버는 연결을 종료할 수 있다.

마찬가지로, 서버가 핸드셰이크 메시지의 HMAC을 전송하면 클라이언트가 불일치 검사를 수행한다.

TLS에서 넌스는 ‘ `연결 재생 공격` ’에 대응하기 위해 사용되고 순서 번호는 진행 중인 세션에서 개별 패킷들의 재생에 대응하기 위해 사용된다.

<br />

### 연결 종료

레코드의 타입 필드에 그 레코드가 TLS 세션 종료를 수행할 것인지를 표시하여 만일 종료 TLS 레코드를 받기 전에 TCP FIN을 받게 되면 뭔가 이상한 일이 진행되고 있음을 알게 될 것이다.

TLS 타입이 암호화 없이 보내지더라도 수신 측에서 레코드의 HMAC을 이용하여 인증된다.

<br />

## 네트워크 계층 보안: IPsec과 가상 사설 네트워크

IPsec이라고 더 잘 알려진 IP 보안 프로토콜은 네트워크 계층의 보안을 제공한다.

IPsec은 호스트나 라우터 같은 네트워크 계층의 어떤 두 개체 사이에서 IP 데이터그램을 보호한다.

두 네트워크 개체 사이의 네트워크 계층 기밀성 기술을 이용해 송신 개체는 수신 개체에 보내는 모든 데이터그램의 페이로드 부분을 암호화한다.

네트워크 계층 보안 프로토콜은 기밀성 외의 보안 서비스도 제공할 수 있다.

IPsec이 기밀성, 출발지 인증, 데이터 무결성, 재생 공격 방지 같은 이 모든 보안 서비스를 어떻게 제공할까?

<br />

### IPsec과 가상 사설 네트워크

공공 인터넷과 완벽하게 분리된, 라우터, 링크, DNS 시스템을 포함하는 물리적으로 독립된 네트워크를 실제로 설치할 수 있을 것이다.

이렇게 분리되어 특정 기관의 전용으로 설치된 네트워크를 사설 네트워크라고 한다.

<img src="https://github.com/user-attachments/assets/ce80eb9d-5974-445f-b62f-4cbf0f16efd5" width="70%" />

사실, 네트워크를 설치하고 유지하는 대신에 오늘날 많은 기관은 기존 공공 인터넷상에 VPN을 구축한다.

VPN을 이용하여 기관의 사무실 간 트래픽은 물리적으로 독립된 네트워크가 아닌 공공 인터넷을 통해 전송된다.

그러나 기밀성을 제공하기 위해 이 트래픽들은 공공 인터넷에 들어가기 전에 암호화된다.

즉, 두 호스트가 공공 인터넷을 통과하는 경로를 이용해서 통신할 때는 트래픽이 인터넷에 들어가기 전에 암호화된다.

게이트웨이 라우터는 평범한 IPv4 데이터그램을 IPsec 데이터그램으로 바꾼 후 인터넷으로 전송한다.

IPsec 데이터그램은 사실 전형적인 IPv4 헤더를 갖고 있어서 공공 인터넷의 라우터들은 이를 평범한 IPv4 데이터그램인 것처럼 처리한다.

<br />

### AH와 ESP 프로토콜

IPsec 프로토콜 모음 내에는 두 가지 주요 프로토콜인 AH(Authentication Header) 프로토콜과 ESP(Encapsulation Security Payload) 프로토콜이 있다.

출발지 IPsec 개체가 보안 데이터그램을 목적지 개체에 보낼 때 AH 프로토콜이나 ESP 프로토콜을 사용한다.

- AH 프로토콜은 출발지 인증과 데이터 무결성을 제공하지만 기밀성은 제공하지 않는다.
- ESP 프로토콜은 출발지 인증, 데이터 무결성, 기밀성을 제공한다.

그래서 ESP 프로토콜이 AH 프로토콜보다 훨씬 널리 사용된다.

<br />

### SA

IPsec 데이터그램을 전송하기 전에 출발지 개체와 목적지 개체는 네트워크 계층에서 논리적 연결을 설립한다.

이 논리적 연결이 SA(security association)다.

SA는 단방향 연결이어서 출발지로붙터 목적지 방향으로만 데이터가 흐를 수 있다.

이 SA를 통해 사용할 암호화 타임과 키, 무결성 검사 타입과 인증키 등 보안에 사용될 다양한 정보를 미리 사전 전달하게 된다.

<br />

### IPsec 데이터그램

<img src="https://github.com/user-attachments/assets/0f1e3e5a-a6be-4aa4-8f27-6816813dd1ae" width="60%" />

<img src="https://github.com/user-attachments/assets/3d0b5646-41a6-4805-b1f0-dd054754cc10" width="60%" />

라우터가 목적지 호스트로 향하는 일반적인 IPv4 데이터그램을 받으면, 라우터는 원본 IPv4 데이터그램을 IPsec 데이터그램으로 변환하기 위해 다음 과정을 이용한다.

- 원 IPv4 데이터그램 뒤에 ESP 트레일러를 덧붙인다.
  - 패딩 : 원래 데이터그램에 덧붙어 최종 메시지가 정수개의 고정 길이 블록으로 분할될 수 있게 한다.
  - 패딩 길이 : 패딩 비트가 얼마나 삽입되었는지 알려주고, 이를 이용해 패딩을 삭제한다.
  - 다음 헤더 : 페이로드에 포함된 데이터의 타입(ex: UDP)을 지시한다.
- SA에 의해 지정된 알고리즘과 키를 이용하여 위의 결과를 암호화한다.
- 암호화된 결과의 앞에 ESP 헤더 필드를 덧붙인다. 결과로 나온 패키지를 ‘엔칠라다(enchilada)라고 부른다.
  - ESP 헤더에는 SPI와 순서번호를 포함한다.
    - SPI : 수신 개체에게 데이터그램이 어느 SA에 속해 있는지 지시한다. 이 SPI를 가지고 자신의 SAD를 검색하여 알맞은 인증 및 복호화 알고리즘과 키를 결정한다.
    - 순서 번호 : 재생 공격을 막기 위해 새용된다.
- SA가 지정한 알고리즘과 키를 이용하여 전체 엔칠라다에 대한 인증 MAC을 생성한다.
- 엔칠라다 뒤에 MAC을 붙여 페이로드를 만든다.
  - 비밀 MAC 키를 엔칠라다에 붙이고 그 결과에 대해 고정 길이의 해시를 계산한다.
- 전형적인 IPv4 헤더 필드를 가지고 완전히 새로운 IP 헤더를 만들어 위의 페이로드 앞에 붙인다.
  - 새로운 IP 헤더에는 출발지와 목적지 주소는 전달될 라우터 인터페이스의 주소가 들어간다.
  - 헤더 필드의 상위 프로토콜 값으로는 TCP,UDP 등을 나타내지 않고 이것이 ESP 프로토콜을 사용하는 IPsec임을 나타내는 값을 사용한다.

라우터가 IPsec 데이터그램을 받으면 다음과 같은 과정을 수행한다.

1. IP 헤더를 보고 IPsec ESP 프로토콜을 적용해야함을 알게된다.
2. 엔칠라다를 들여다보고 SPI를 이용하여 데이터그램이 어느 SA에 속한것인지 알아낸다.
3. 엔칠라다의 MAC을 계산하여 ESP MAC 필드의 값과 일치하는지 확인한다.
   - 일치하여야 조작되지 않은 것이다. (무결성)
4. 데이터그램이 재생된 것이 아닌지 순서 번호 필드를 검사한다.
5. SA와 관련된 복호화 알고리즘과 키를 이용하여 암호화된 부분을 복호화한다.
6. 원래의 IP 데이터그램을 최종 목적지로 전송하기 위해 지점 네트워크로 전달한다.

IPsec 개체는 SAD와 함께 SPD(security policy database)라 불리는 자료구조를 유지한다.

SPD는 어떤 형태의 데이터그램(출발지 IP 주소, 목적지 IP 주소, 프로토콜 타입으로 결정)이 IPsec으로 처리되어야 하는지와 그때 사용될 SA를 지시한다.

즉, SPD의 정보는 도착한 데이터그램으로 무엇을 할지 알려주고, SAD의 정보는 어떻게 할 것인지를 알려준다.

SAD는 모든 SA에 대한 상태 정보를 저장한 데이터 구조이다.

<br />

## 방화벽

방화벽은 전체 인터넷으로부터 기관의 내부 네트워크를 분리시킨 하드웨어와 소프트웨어의 조합으로, 어떤 패킷은 통과가 허용되나 어떤 패킷은 차단된다.

방화벽은 네트워크 관리자가 해당 네트워크에 대한 트래픽 출입을 관리함으로써 외부 세계와 관리 네트워크 내 자원 간의 접속을 제어할 수 있게 한다.

<br />

[ 방화벽의 목표 ]

1. 외부와 내부를 오가는 모든 트래픽은 방화벽을 거친다.
2. 로컬 보안 정책에 정의된 대로 승인된 트래픽만이 통과가 허용된다.
3. 방화벽 자체가 침입 시도에 안전해야 한다.

방화벽은 빈번하게 라우터에 구현되고 SDN을 사용하여 원격으로 제어된다.

방화벽은 전토적인 패킷 필터, 상황 고려 필터, 애플리케이션 게이트웨이 세 가지로 분류할 수 있다.

<br />

### 전통적인 패킷 필터

하나의 기관은 일반적으로 내부의 네트워크를 ISP에 연결하는 게이트웨이 라우터를 갖는다.

내부 네트워크에 대한 모든 입출력 트래픽은 이 라우터를 통과해야 하고, 이 라우터에서 패킷 필터링이 일어난다.

패킷 필터는 각 데이터그램을 따로따로 독립적으로 검사하면서 관리자의 특정한 규칙에 따라 데이터그램을 통과시킬지 버릴지 결정한다.

필터링 정책은 주소와 포트 번호의 조합에 기초한다.

불행하게도 외부 주소에 기초한 정책은 출발지 주소를 위장한 데이터그램을 막을 수 없다.

방화벽 규칙은 접속 제어 목록과 함께 라우터에 구현된다.

각 라우터 인터페이스는 자신만의 목록을 갖는다.

<br />

### 상황 고려 패킷 필터

전통적인 패킷 필터에서는 패킷 차단 결정이 각 패킷에 대해 따로따로 이루어진다.

반면, 상황 고려 필터는 TCP 연결을 추적하여 이 정보를 패킷 차단 결정을 하는 데 이용한다.

방화벽이 세 방향 핸드셰이크(SYN, SYNACK, ACK)를 관찰함으로써 새로운 연결의 시작을 알 수 있고, 그 연결에 대해 FIN을 발견함으로써 연결의 종료를 알 수 있기 때문에 가능하다.

패킷이 방화벽에 도착하면 방화벽은 접속 제어 목록을 살펴보는데, 여기에 이 패킷이 기관 네트워크로 들어가는 것을 허가하기 전에 연결 테이블이 반드시 검사되어야 한다는 필드에 표시가 되어 있다면 먼저 검사를 진행한다.

방화벽은 연결 테이블을 검사하게 되고, 이 패킷이 진행 중인 TCP 연결 어느 것에도 속해 있지 않다면 패킷은 버려진다.

<br />

### 애플리케이션 게이트웨이

패킷 수준 필터링이은하나의 기관에게 IP 주소, 포트 번호, ACK 비트 등과 같은 IP와 TCP/UDP 헤더 내용에 기반을 둔 넓은 단위의 필터링이 가능하다.

그러나 만일 어떤 기관이 제한된 범위의 일부 내부 사용자들에게만 서비스를 제공하고자 한다면 어떻게 해야할까?

좀 더 세밀한 수준의 보안을 위해 방화벽은 패킷 필터를 애플리케이션 게이트웨이와 결합해야 한다.

애플리케이션 게이트웨이는 IP/TCP/UDP 헤더 이상의 것을 살펴보고, 애플리케이션 데이터에 기초한 정책 결정을 한다.

애플리케이션 게이트웨이는 모든 애플리케이션 데이터가 반드시 통과해야 하는 애플리케이션 맞춤 서버다.

애플리케이션 게이트웨이는 사용자 인증을 수행할 뿐만 아니라, 사용자와 원격 서버 간의 정보를 전달해주는 서버와 클라이언트로 동작한다.

하지만 애플리케이션 게이트웨이는 다음과 같은 단점이 있다.

<br />

[ 단점 ]

1. 각 애플리케이션마다 서로 다른 애플리케이션 게이트웨이를 필요로 한다.
2. 모든 데이터가 게이트웨이를 경유하여 중계되므로 성능상의 손실이 있다.
3. 클라이언트 소프트웨어는 사용자가 요구할 때 어떻게 게이트웨이와 통신할 수 있는지 알아야 하며, 어떤 외부 서버에 연결할지 애플리케이션 게이트웨이에게 알려줄 수 있어야 한다.

<br />

## 침입 탐지 시스템

다양한 형태의 공격을 탐지하기 위해서는 헤더 필드 내용 외에도 패킷이 갖고 있는 실제 애플리케이션 데이터의 내용까지 살펴보는 자세한 패킷 관찰을 할 필요가 있다.

애플리케이션 게이트웨이는 종종 자세한 패킷 관찰을 한다.

하지만 하나의 애플리케이션 게이트웨이는 한 가지 특정한 애플리케이션에 대해서만 수행된다.

의심스러운 하나의 패킷이나 패킷들의 의심스러운 연속을 발견했을 때 패킷들이 기관 네트워크로 들어가는 것을 막을 수도 있다.

- 악의적일 수 있는 트래픽을 발견했을 때 경고를 발생시키는 장치를 침입 탐지 시스템(IDS)라고 한다.
- 의심스러운 트래픽을 걸러내는 장치는 침입 방지 시스템(IPS)라고 한다.

네트워크 구성 정보 수집, 포트 정보 수집, TCP 스택 정보 수집, DoS 대역폭 플러딩 공격, 웜과 바이러스, OS 취약점 공격, 애플리케이션 취약점 공격 등 넓은 범위의 공격을 탐지하는 데 사용될 수 있다.
