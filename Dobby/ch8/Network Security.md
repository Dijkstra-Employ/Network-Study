## 네트워크 보안

- 기밀성
  - 송신자와 지정된 수신자만이 전송되는 메시지 내용을 이해할 수 있어야 한다.
- 메시지 무결성
  - 신뢰적인 전송 및 데이터 링크 프로토콜을 위해 사용했던 체크섬 기술을 확장함으로써 메시지 무결성을 제공할 수 있다.
- 종단점 인증
  - 송신자와 수신자는 통신에 참여하는 상대방이 실제 누구인지 확인하기 위해 상대방의 신원을 확인할 수 있어야 한다.
- 운영 보안
  - 방화벽은 기관 네트워크와 공공 네트워크 사이에 설치되어 두 네트워크 사이를 오가는 패킷들을 제어한다.
  - 침입 감지 시스템은 패킷을 상세히 관찰하고 의심스러운 행위에 대해 네트워크 관리자에게 보고한다.

<br />

## 암호화

암호 기술은 송신자가 데이터를 변형시켜서 침입자가 가로챈 데이터로부터 아무런 정보도 얻지 못하도록 하기 위한 것이다.

물론, 수신자는 변형된 데이터로부터 원래 데이터를 복원해낼 수 있어야 한다.

- 대칭키 시스템
  - 송신자와 수신자의 키가 동일하고 이 키는 둘만 알고 있어야 한다.
- 공개키 시스템
  - 한 쌍의 키가 사용된다. (공개키, 개인키)

<br />

### 대칭키 암호화

암복호화키가 동일하며 해당 키를 아는 사람만이 문서를 복호화해 볼 수 있게 된다.

공개키 암호화 방식에 비해 속도가 빠르다는 장점이 있지만, 키를 교환해야 한다는 문제(키 배송 문제)가 발생한다.

키를 교환하는 중 키가 탈취될 수 있는 문제도 있고 사람이 증가할수록 전부 따로따로 키 교환을 해야하기 때문에 관리해야 할 키가 방대하게 많아진다.

이러한 키 배송 문제를 해결하기 위한 방법으로 키의 사전 공유에 의한 해결, 키 배포센터에 의한 해결, 공개키 암호화에 의한 해결이 있다.

![image](https://github.com/user-attachments/assets/869b4e86-997a-4157-91b6-650011c36b14)

<br />

### 공개키 암호화

대칭키의 키교환 문제를 해결하기 위해 등장한 것이 공개키(비대칭키) 암호화 방식이다.

이름 그대로 키가 공개되어 있기 때문에 키를 교환할 필요가 없어지며 공개키는 모든 사람이 접근 가능하고 개인키는 각 사용자만이 가지고 있는 키이다.

![image](https://github.com/user-attachments/assets/e3508d66-f9e6-4e36-b762-a920f5253670)

1. B 공개키/개인키 쌍 생성
2. 공개키 공개(등록), 개인키는 본인이 소유
3. A가 B의 공개키를 받아옴
4. A가 B의 공개키를 사용해 데이터를 암호화
5. 암호화된 데이터를 B에게 전송
6. B는 암호화된 데이터를 B의 개인키로 복호화 (개인키는 B만 가지고 있기 때문에 B만 볼 수 있음)

공개키는 키가 공개되어 있기 때문에 따로 키 교환이나 분배를 할 필요가 없어진다.

중간 공격자가 B의 공개키를 얻는다고 해도 B의 개인키로만 복호화가 가능하기 때문에 기밀성을 제공하며 개인키를 가지고 있는 수신자만이 암호화된 데이터를 복호화할 수 있으므로 일종의 인증기능도 제공한다는 장점이 있다.

그에 반해 단점은 속도가 느리다는 것이다.

그래서 처음에 공개키 암호화로 세션 키를 교환하고, 해당 키로 대칭키 암호화를 진행한다.

<br />

## 메시지 무결성과 전자서명

링크 상태 알고리즘에서 각 라우터는 네트워크 내의 다른 라우터에게 링크 상태 메시지를 보내야 한다.

라우터의 링크 상태 메시지는 직접적으로 연결된 이웃들의 목록과 이 이웃들의 연결 비용을 포함하고 있다.

일단 한 라우터가 다른 모든 라우터로부터 링크 상태 메시지를 받으면 네트워크 전체 지도를 생성해낼 수 있고, 최소 비용 라우팅 알고리즘을 수행하여 포워딩 테이블을 설정할 수 있다.

침임자 트루디가 라우팅 알고리즘에 행할 수 있는 비교적 단순한 공격은 잘못된 링크 상태 정보를 담은 가짜 링크 상태 메시지르르 배포하는 것이다.

따라서, 메시지 무결성이 필요하다.

<br />

### 암호화 해시 함수

암호화 해시 함수는 디지털 서명, 메시지 인증 코드(MAC) 및 기타 인증 형식을 포함한 다양한 암호화 응용 프로그램에 사용되도록 설계된 특수한 유형의 해시 함수이다.

암호화 해시 함수는 다른 해시 함수와 구별되는 몇 가지 필수 속성을 가지고 있다.

1. 결정론: 동일한 입력 메시지는 항상 동일한 해시 값을 생성한다.
2. 효율성: 입력 크기에 관계없이 해시 값이 빠르게 계산된다.
3. 충돌 저항: 동일한 해시 값을 생성하는 두 개의 서로 다른 메시지를 찾는 것은 계산상 불가능하다.
4. 이미지 저항: 해시 값이 주어지면 해당 특정 해시를 생성하는 메시지를 생성하는 것이 불가능하다.
5. 눈사태 효과: 입력 메시지의 작은 변경으로 인해 출력 해시에 상관 관계가 없어 보이는 중요한 변경이 발생한다.

[ **일반적인 암호화 해시 함수** ]

- MD5: 한때 인기가 있었지만 이제는 암호화되어 있어 보안 애플리케이션에 적합하지 않은 것으로 간주된다.
- SHA-1: 이전에는 널리 사용되었지만, 현재는 보안 취약성으로 인해 더 이상 사용되지 않는다.
- SHA-2: SHA-256은 현재 가장 일반적으로 사용되는 변종이다.
- SHA-3: 특정 유형의 공격에 대한 저항력을 더욱 강화하도록 설계된 보안 해시 알고리즘 제품군의 최신 구성원이다.

[ **암호화 해시 함수의 응용** ]

- 디지털 서명: 메시지의 고정 크기 다이제스트를 생성하는 데 사용되며, 이 다이제스트는 보낸 사람의 개인 키로 암호화된다.
- 파일 무결성 확인: 웹사이트에서는 다운로드 가능한 파일에 대한 해시 값을 게시하여 사용자가 다운로드 후 파일의 무결성을 확인할 수 있는 경우가 많다.
- 비밀 번호 보안: 비밀번호는 일반적으로 일반 텍스트가 아닌 해시로 저장되어 보안이 강화된다.
- Blockchaing 기술: 비트코인과 같은 암호화폐는 암호화 해시 기능(예: SHA-256)을 사용하여 거래 기록의 무결성과 보안을 유지한다.
- SSL/TLS 프로토콜

<br />

### 메시지 인증 코드

1. 앨리스는 메시지 m을 생성하고 해시 H(m)을 계산한다.
2. 앨리스는 메시지 m에 H(m)을 첨부하여 확장 메시지 (m, H(m))을 생성한 후 밥에게 보낸다.
3. 확장 메시지 (m, h)를 받은 밥은 H(m)을 계산한다. 만일 H(m) = h라면, 밥은 모든 것이 문제없이 처리되었다고 결론지을 수 있다.

위의 방법은 트루디가 가짜 메시지 m’을 생성하여 메시지 내에서 자신이 앨리스라고 주장한 후, H(m’)을 생성하여 밥에게 (m’, H(m’))을 보낼 수 있다.

위와 같은 상황을 위해 메시지 무결성이 필요하며, 메시지 무결성은 암호화 해시 함수의 사용 외에도 앨리스와 밥이 비밀키 s를 공유할 필요가 있다.

1. 앨리스는 메시지 m을 생성한 후 s와 접합하여 m + s를 만든다. 그런 다음 해시 H(m + s)를 계산해내는데, 이것을 메시지 인증 코드(MAC)이라고 부른다.
2. 앨리스는 MAC으르 메시지 m에 첨부하여 확장 메시지 (m, H(m + s))를 생성해서 밥에게 보낸다.
3. 밥은 확장 메시지 (m, h)를 받으면 이미 알고 있는 s를 이용하여 MAC H(m + s)를 계산한다. 만일 H(m + s) = h라면, 밥은 아무 문제가 없다고 결론짓는다.

- 여기서 MAC은 링크 계층 프로토콜의 MAC과 같지 않다.

MAC의 유용한 특성 중 하나는 암호화 알고리즘을 필요로 하지 않는다는 점이다.

[ **공유 인증키 s를 통신 개체들에게 배포하는 방법** ]

각각의 라우터가 자신만의 공개키를 갖고 있다면, 인증키는 각 라우터의 공개키로 암호화되어 네트워크를 통해 전달될 수 있다.

<br />

### 전자서명

전자서명은 디지털 세계에서 메시지 무결성과 사용자 인증을 위해 사용되는 암호화 기법이다.

손으로 한 서명처럼 전자서명은 서명자를 입증할 수 있어야 하고, 위조할 수 없도록 해야 한다.

밥이 메시지에 서명할 때 밥은 자신의 고유한 무엇인가를 메시지에 포함시켜야 한다.

자신의 고유 비밀키를 메시지에 첨부하고 이를 해시 함수에 넣어서 만들어진 MAC을 서명으로 쓰는 방법을 고려해볼 수 있다.

→ 자신의 개인키로 메시지를 암호화하고, 수신자는 송신자의 공개키로 메시지를 복호화함으로써 사용자 인증 및 무결성을 보장할 수 있다.

우리는 전자서명이 수신자에게 송신자의 신분뿐만 아니라 메시지 자체가 변형되지 않았음을 확인할 수 있게 함으로써 메시지 무결성을 제공한다는 사실을 알 수 있다.

암호화 기술을 이용한 전자서명의 한 가지 문제점은 암호화와 복호화를 위한 연산이 과중하다는 것이다.

좀 더 효율적인 방법은 해시 함수를 전자서명에 이용하는 것이다.

해시 알고리즘은 임의 길이의 메시지 m을 가지고 H(m)으로 표현되는 고정 길이의 ‘지문’을 계산해낸다.

해시 함수를 수행한 후에 밥은 메시지 자체가 아니라 메시지의 해시 결과에 서명한다.

일반적으로 H(m)은 원래 메시지 m보다 훨씬 짧으므로, 전자서명을 생성하기 위한 연산 작업의 부하가 훨씬 줄어든다.

[ **밥이 앨리스에게 메시지를 보내는 상황** ]

1. 밥은 원래의 긴 메시지에 해시 함수를 적용한 후, 해시 결과에 그의 개인키로 전자서명을 한다.
2. 전자적으로 서명된 메시지 요약문과 함께 원래 메시지(평문)이 앨리스에게 전달된다.
3. 앨리스는 송신자의 공개키를 메시지에 적용해서 해시 결과를 얻는다.
4. 해시 함수를 평문에 적용해서 두 번째 해시 결과를 얻는다.
5. 이 두 해시값이 일치하다면, 앨리스는 메시지의 무결성과 작성자의 진위에 대해 확신할 수 있다.

<br />

### 공개키 인증

공개키 인증은 IPsec과 TLS를 포함한 많은 대중적인 보안 네트워킹 프로토콜에서 사용된다.

공개키가 어떤 특정한 통신 개체의 것인지 보증하는 일은 일반적으로 인증기관(CA)에서 담당하는데, 이들이 하는 일은 신원을 확인하고 인증서를 발행하는 것이다,

[ **CA의 역할** ]

- 어떤 개체(사람, 라우터 등)가 스스로 주장하는 자신의 신분, 바로 그 개체가 맞는지 확인한다.
- 일단 CA가 개체의 신원을 확인하면, CA는 그 개체의 공개키와 신분 확인서를 결합한 인증서를 만든다.
- 이 인증서는 공개키와 함께 이 공개키의 주인에 대한 고유한 식별 정보를 담고 있다.
- 인증서에는 CA가 전자서명을 한다.

밥이 CA가 서명한 그의 인증서를 앨리스에게 보낸다.

앨리스는 CA의 공개키를 사용하여 밥의 인증서의 유효성을 검사하고, 밥의 공개키를 뽑아낸다.

<br />

## 종단점 인증

종단점 인증이란 하나의 통신 개체가 다른 개체에게 자신의 신원을 컴퓨터 네트워크상으로 증명하는 작업이다.

인증은 인증 프로토콜의 한 부분으로서 교환된 메시지와 데이터만을 기반으로 수행되어야 한다.

대개 인증 프로토콜은 두 통신 관계자가 어떤 다른 프로토콜을 수행하기 이전에 수행된다.

인증 프로토콜은 먼저 서로의 요구에 맞춰 통신 당사자들의 신원을 확인한다.

인증 후에야 통신 당사자들은 실제 작업을 시작할 수 있다.

<br />

### 인증 프로토콜 ap4.0

넌스(nonce)는 프로토콜이 평생에 단 한 번만 사용하는 숫자를 뜻한다.

즉, 프로토콜이 한 번 어떤 넌스를 사용하면 이 숫자를 절대로 다시 사용하지 않는다.

프로토콜 ap4.0은 넌스를 다음과 같이 사용한다.

1. 앨리스는 메시지 “나는 앨리스다”를 밥에게 보낸다.
2. 밥은 넌스 R을 선택하고 그것을 앨리스에게 보낸다.
3. 앨리스는 앨리스와 밥의 대칭 비밀키를 사용해서 그 넌스를 암호화하고, 암호화된 넌스를 밥에게 보낸다. 상대방이 대칭 비밀키를 알고 있고 이것을 암호화에 사용했으므로 밥은 자신이 받은 메시지를 앨리스가 만들었다는 사실을 알게 된다. 앨리스가 현재 실제 통신 중임을 확인하기 위해 넌스가 사용된다.
4. 밥은 자신이 받은 메시지를 복호화한다. 만약 복호화한 넌스가 자신이 앨리스에게 보낸 것과 같다면 앨리스를 인증한다.

일회용인 R을 사용하고 반환되는 값(암호화된 R)을 확인함으로써 밥은 스스로 앨리스라고 주장하는 사람이 진짜 앨리스라는 것(R의 암호화에 필요한 비밀키를 알고 있기 때문에)과 실제로 현재 통신 중이라는 것 두 가지를 확신할 수 있다.
