## 거리 벡터 라우팅 알고리즘

링크 상태 알고리즘이 네트워크 전체 정보를 이용하는 알고리즘인 반면에, 거리 벡터 알고리즘은 반복적이고 비동기적이며 분산적이다.

각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포한다는 점에서 분산적이다.

이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다는 점에서 반복적이다.

LS 알고리즘은 다익스트라 알고리즘을 수행하기 전에 각 노드가 네트워크에 대한 전체 지도를 먼저 얻어야 한다는 면에서 중앙 집중형 알고리즘이다.

DV 알고리즘은 분산적이고 그러한 전체 정보를 사용하지 않는다.

하나의 노드가 갖는 정보는 단지 자신에게 직접 연결된 이웃으로의 링크 비용과 그 이웃들로부터 수신하는 정보뿐이다.

각 노드는 이웃으로부터의 갱신을 기다리고, 업데이터를 수신하면 새로 거리 벡터를 계산하고, 이 새로운 거리 벡터를 이웃들에게 배포한다.

노드 x가 이웃 w에게서 새로운 거리 벡터를 수신하면, x는 w의 거리 벡터를 저장하고 벨만-포드 식을 사용하여 자신의 거리 벡터를 갱신한다.

```jsx
Dx(y) = min{c(x, v) + Dv(y)}
```

갱신을 계속하다보면, 실제 최소 비용 경로의 비용으로 수렴하게 된다.

<br />

### 링크 비용 변경과 링크 고장

링크 비용이 감소할 때는 최소 비용을 계산하는 과정으로 인해 정상적으로 포워딩 테이블이 갱신된다.

하지만 링크 비용이 증가할 때 최소 비용을 계산하기 때문에 라우팅 루프 문제가 발생하게 된다.

이런 문제를 `무한 계수 문제(count-to-infinity problem)`이라고 한다.

이는 링크 비용이 증가했더라도 다른 라우터에선 최소 비용을 계산할 때 증가한 비용이 최소가 되지 않기에 적용하지 않게 되어 발생하는 것이다.

이러한 문제(라우팅 루프 시나리오)는 `포이즌 리버스`라는 방법을 사용해 방지할 수 있다.

포이즌 리버스는 한 라우터가 경로 설정을 갱신하게 되면 중간 경유지 라우터에겐 목적지까지의 비용이 무한대라고 알려 최소 비용을 다시 계산하게 하는 것이다.

하지만 이러한 포이즌 리버스 방법도 모든 무한 계수 문제를 해결할 수는 없다.

직접 이웃한 2개의 노드가 아닌 3개 이상의 노드를 포함한 루프는 이 방법으로 해결할 수 없다.

<br />

### 링크 상태 알고리즘 vs 거리 벡터 라우팅 알고리즘

- 메시지 복잡성

  `링크 상태 알고리즘`에서 각 노드는 네트워크 내 각 링크 비용을 알아야 하며, 링크 비용이 변할 때마다 새로운 링크 비용이 모든 노드에게 전달되어야 한다.

  `거리 벡터 알고리즘`에서는 매 반복마다 직접 연결된 이웃끼리 메시지를 교환한다.

  링크 비용이 변하고, 이 새로운 링크 비용이 이 링크에 연결된 어떤 노드의 최소 비용 경로에 변화를 준 경우에만 DV 알고리즘은 수정된 링크 비용을 전파한다.

- 수렴 속도

  링크 상태 알고리즘은 브로드캐스트를 해야하므로 O(n^2) 알고리즘이며 거리 벡터 알고리즘은 라우팅 루프로 인한 무한 계수 문제가 발생할 수 있다.

- 견고성
  만약 라우터가 고장나거나 오동작하거나 파손된다면 어떤 일이 발생할까?
  `링크 상태 알고리즘`에서 경로 계산은 자신의 테이블을 만들기 위한 자신의 포워딩 테이블만 계산하기 때문에 경로 계산이 분산 수행되어 어느 정도의 견고성을 제공한다.
  `거리 벡터 알고리즘`은 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있다.
  각 반복마다 한 노드의 거리 벡터 계산이 이웃에게 전달되고, 다음 반복에서 이웃의 이웃에게 간접적으로 전달된다.
  이런 측면에서 거리벡터 알고리즘을 사용하는 네트워크에서 한 노드의 잘못된 계산은 전체로 확산될 수 있다.
