## Pipelined protocols

TCP가 동작하는 방식

신뢰성을 보장하면서 빠른 속도를 제공할 수 있다.

rdt3.0의 핵심적인 성능 문제는 rdt3.0이 전송 후 대기 프로토콜이라는 점이다.

전송 후 대기 프로토콜은 형편없는 송신자 이용률을 갖는다.

이러한 방식 대신, 확인응답을 기다리지 않고 여러 패킷을 전송하도록 한다.

만약 확인응답들을 기다리기 전에 송신자가 3개의 패킷을 전송하도록 허용한다면 송신자 이용률은 3배가 된다.

많은 전송 중인 송신자-수신자 패킷을 파이프라인에 채워 넣음으로써 나타낼 수 있다.

이를 `파이프라이닝` 이라고 한다.

<br />

- 순서 번호의 범위가 커져야 한다.
  각각의 전송 중인 패킷은 유일한 순서 번호를 가져야 하는데, 전송 중인 확인응답이 안된 패킷이 여럿 있을지도 모르기 때문이다.

- 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다.
  최소한 송신자는 전송되었으나 확인응답되지 않은 패킷을 버퍼링해야 한다.

- 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려 있다.
  파이프라인 오류 회복의 두 가지 기본적인 접근 방법으로 GBN(Go-Back-N)과 SR(Selective Repeat) 등이 있다.

<br />

### GBN

GBN 프로토콜에서 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.

그러나 파이프라인에서 확인응답이 안 된 패킷의 최대 허용 수 N보다 크지 말아야 한다.

![image](https://github.com/user-attachments/assets/cb9f1e26-6f08-4e3d-9027-bef526956a18)

GBN 프로토콜은 슬라이딩 윈도 프로토콜이라고 부른다.

GBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다.

이 기술에는 순서 번호, 누적 확인응답, 체크섬, 타임아웃/재전송 동작에 대한 사용이 포함된다.

<br />

### SR

수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피한다.

필요에 따라 각각 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인응답을 요구할 것이다.

<br />

## TCP

`reliable data transfer` : rdt

- TCP는 핸드셰이크를 통해 다른 프로세스와 연결을 하는 연결지향형 프로토콜이다.
- TCP 프로토콜은 오직 종단 시스템에서만 동작하고 중간의 네트워크 요소(라우터와 링크 계층 스위치)에서는 동작하지 않으므로, 중간의 네트워크 요소들은 TCP 연결 상태를 유지하지 않는다.
- TCP 연결은 전이중 서비스를 제공한다.
- 단일 송신 동작으로 한 송신자가 여러 수신자에게 데이터를 전송하는 멀티캐스팅은 TCP에서는 불가능하다.
  UDP에서는 가능하다.

<br />

### TCP를 통한 데이터 전송

- 클라이언트 프로세스는 소켓을 통해 데이터의 스트림을 전달한다.
- 데이터가 관문(소켓)을 통해 전달되면, 이제 데이터는 클라이언트에서 동작하고 있는 TCP에 맡겨진다.
- TCP는 초기 세 방향 핸드셰이크 동안 준비된 버퍼 중의 하나인 연결된 송신 버퍼로 데이터를 보낸다.
- 송선 버퍼에서 세그먼트로 모아 담을 수 있는 최대 데이터의 양만큼 묶어 데이터를 전달한다.
  이때 최대 세그먼트 크기(maximum segment size)를 `MSS`라고 한다.
- MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(최대 전송 단위, MTU)에 의해 결정되고, TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다.
- TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 TCP 세그먼트를 구성한다.
- 세그먼트는 네트워크 계층에 전달되며, 네트워크 계층 IP 데이터그램 안에 각각 캡슐화된다.

```
💡 MSS는 헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라, 세그먼트에 있는 애플맄케이션 계층 데이터에 대한 최대 크기라는 점을 주의해야 한다.
```

<br />

### TCP 세그먼트 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/44513d1a-3c6e-47bd-8f6c-a1e1d942ab3c/Untitled.png)

| 출발지와 목적지 포트      | TCP는 UDP처럼 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는 데 사용된다.     |
| ------------------------- | -------------------------------------------------------------------------------------- |
| 체크섬 필드               | 데이터 유효성을 판단한다.                                                              |
| 순서 번호 필드            |                                                                                        |
| 확인응답 번호 필드        |                                                                                        |
| 수신 윈도                 | 흐름 제어에 사용된다. 이는 수신자가 받아들이려는 바이트의 크기를 나타내는 데 사용된다. |
| 헤더 길이 필드            | TCP의 헤더는 가변적인 길이가 될 수 있다.                                               |
| ACK 플래그 비트           | 확인응답 필드에 있는 값이 유용함을 가리키는데 사용한다.                                |
| RST, SYN, FIN 플래그 비트 | 연결 설정과 해제에 사용된다.                                                           |
| PSH 플래그 비트           | 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 나타낸다.                             |
| URG 플래그 비트           | 이 세그먼트에서 송신 측 상위 계층 개체가 ‘긴급’으로 표시하는 데이터임을 가리킨다.      |

TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.

TCP의 순서 번호 사용은 순서 번호가 일련의 전송된 세그먼트에 대해서가 아니라, 전송된 바이트의 스트림에 대해서라는 관점을 반영한 것이다.

(즉, 바이트 기준으로 sequense number를 설정한다.)

세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.

확인 응답 번호는 송신자가 수신자로부터 기대하는 다음 바이트의 순서 번호다.

TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에, TCP는 `누적 확인응답`을 제공한다고 한다.

<br />

[ 중복된 데이터를 전달받았을 때의 가능한 동작 ]

1. 수신자가 순서가 바뀐 세그먼트를 즉시 버린다.
2. 수신자는 순서가 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 기다린다.

<br />

### SampleRTT

RTT 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이

세그먼트를 보낼 때마다 타이머를 재서, 일정 시간이 지나면 만료시킨 후 재전송한다.

재전송한 세그먼트에 대해선 sample RTT를 포함시키지 않는다.

타이머는 TCP (소켓) 별로 작동한다.

세그먼트 loss 시 총 4회의 중복 ack를 통해 재전송한다. (fast retransmit)

TCP는 sampleRTT값의 평균을 유지한다.

긍정 확인응답을 수신하고 새로운 sampleRTT를 획득하자마자 TCP는 평균 값(가중 평균, EstimatedRTT)을 갱신한다.

EstimatedRTT는 SampleRTT 값의 가중평균이며, 예쩐 샘플보다 최근 샘플에 높은 가중치를 준다.

이는 최근 샘플들이 네트워크상의 현재 혼잡을 더 잘 반영하기 때문이다.

<br />

### 재전송 타임아웃 주기

주어진 EstimatedRTT 값이 TCP 타임아웃 주기보다 크거나 같아야 한다.

그렇지 않다면, 불필요한 재전송이 보내질 것이다.

타임아웃값은 EstimatedRTT에 약간의 마진 값을 더한 값으로 설정한다.

<br />

### Receive buffer, Send buffer

- receive buffer를 통해서 in-order를 제공한다.
- receive buffer는 정상적으로 데이터를 받으면 해당 바이트를 receive socket으로 올려준다.
- send buffer에서 데이터는 receive buffer로부터 확인 응답이 오고, 재전송할 필요가 없을 때 지운다.
- 즉, send buffer는 재전송을 위한 buffer이며, receive buffer는 순서를 맞추기 위한 buffer이다.

<br />

### 빠른 재전송

타임아웃이 유발하는 재전송의 한 가지 문제는 타임아웃의 주기가 때때로 비교적 길다는 것이다.

세그먼트를 잃었을 때, 긴 타임아웃 주기는 잃어버린 패킷을 다시 보내기 전에 송신자를 오랫동안 기다리게 해서 종단 간의 지연을 증가시킨다.

이를 위해 고안된 방법이, 타임아웃이 발생하기 전에 3번의 중복된 ACK를 받게 되면 세그먼트 재전송을 실시하는 것이다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/9cfbea95-0031-4f87-b9d8-0c3c22026c41/image.png)

3개의 중복된 ACK를 수신할 때, TCP는 세그먼트의 타이머가 만료되기 이전에 손실 세그먼트를 재전송하는 빠른 재전송 (fast retransmit)을 한다.

<br />

## 흐름 제어

TCP 연결이 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정한다.

TCP 연결이 순서대로 올바르게 바이트를 수신할 때 TCP는 데이터를 수신 버퍼에 저장한다.

해당 애플리케이션 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에 읽을 필요는 없으며, 애플리케이션이 데이터를 읽는 속도가 비고적 느리다면, 송신자가 점점 더 많은 데이터를 빠르게 전송함으로써 연결의 수신 버퍼에 아주 쉽게 오버플로를 발생시킬 것이다.

이처럼 TCP는 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 애플리케이션에게 흐름 제어 서비스를 제공한다.

즉, 수신하는 애플리케이션이 읽는 속도와 송신자가 데이터를 전송하는 속도를 같게 한다.

<br />

### 수신 윈도

TCP는 송신자가 수신 윈도(receive window)라는 변수를 유지하여 흐름 제어를 제공한다.

수신 윈도는 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주는데 사용된다.

이때 할당된 수신 버퍼의 크기를 RcvBuffer라고 명명한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/a91b1b00-9163-486c-ae71-e20f74b14a46/image.png)

연결은 흐름 제어 서비스를 제공하기 위해 변수 rwnd를 어떻게 사용할까?

호스트는 전송하는 모든 세그먼트의 윈도 필드에 현재의 rwnd 값을 설정함으로써 연결 버퍼에 얼마만큼의 여유 공간이 있는지를 상대 호스트에게 알려준다.

rwnd의 값보다 작은 확인응답 안된 데이터의 양을 유지함으로써 호스트는 상대 호스트의 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다.

TCP는 호스트가 상대 호스트의 수신 윈도가 0일 때, 1바이트 데이터로 세그먼트를 계속해서 전송하도록 요구한다.

이는 rwnd가 0이 됐을 때 상대 호스트는 더이상의 데이터를 전송하지 않는 상황에서의 문제 때문이다.

여기서 애플리케이션이 송신 호스트의 receive Buffer의 데이터를 읽게되면 여유 공간이 남게 되지만, 수신 호스트에게 전송할 데이터도, 받을 데이터도 없을 때 상대 호스트는 언제 데이터를 보내야 하는지 알 수 없게 된다.

그래서 수신 윈도가 0일 때, 1바이트 데이터로 세그먼트를 계속해서 전송하여 수신 윈도의 상태를 확인한다.

<br />

## 3-way-handshake

클라이언트 호스트의 연결 요청, 서버 호스트의 연결 승인, 클라이언트 호스트의 연결 승인에 대한 ACK 세그먼트(일부 데이터 포함)를 보냄으로써 TCP 연결을 수행한다.

또한 이 연결이 종료된 후에는 클라이언트와 서버 호스트들은 각각 서로에게 데이터를 포함하는 세그먼트를 보낼 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/27dda761-c911-4db7-ba8f-7e2fe00c4c02/image.png)

<br />

## TCP 연결 종료

클라이언트 애플리케이션 프로세스는 종료 명령(FIN)을 내리고, 서버 프로세스는 ACK 세그먼트를 보낸다.

그리고 서버 호스트가 종료 할 수 있는 상태가 된 후에 FIN 세그먼트를 클라이언트 호스트에게 전달한다.

클라이언트 호스트는 FIN 세그먼트에 대한 ACK 세그먼트를 서버 호스트에게 전달한 후 종료한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/9292a090-3ea3-42d3-b3ff-8435c30c2718/image.png)

클라이언트 호스트는 FIN 세그먼트를 받고 ACK를 보낸 후 일정 시간 대기한다.

이는 ACK 세그먼트가 Loss 될 수 있기 때문이며, 이럴 경우 서버 호스트는 ACK를 받지 못했으므로 계속해서 FIN 세그먼트를 클라이언트에게 전송할 것이다.

[ 클라이언트 TCP에서 TCP 상태 전이의 일반적인 순서 ]

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8f34238a-246a-4ffd-8d8a-f3a45a9148ed/bb1128e4-073b-4639-9f71-c121ca2f2426/image.png)

[ 서버 측 TCP에서 TCP 상태 전이의 일반적인 순서 ]
