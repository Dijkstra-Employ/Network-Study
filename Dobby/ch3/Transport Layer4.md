## 혼잡 제어

네트워크에서 지연이 발생했을 때 세그먼트 송신을 제어할 수 있다.

네트워크에 많은 데이터가 전달되었을 때 발생하며, 교통체증과 유사하다.

패킷 유실이 발생할 수 있으며, 라우터 지연이 발생하게 된다.

혼잡이 발생하면 재전송으로 인해 애플리케이션이 전송하고자 하는 데이터의 양보다 TCP에서 전송하는 데이터의 양이 더 많아진다.

즉, 실제로 필요한 양보다 네트워크에 나가는 데이터의 양이 많아진다.

송신측에서 데이터 전달의 속도를 높이면, 수신측에서는 받는 데이터의 양이 늘어나다가, 어느 시점을 기준으로 받게 되는 데이터의 양이 줄어들게 된다.

이는 네트워크 혼잡에 의한 현상이다.

<br />

### 혼잡 지연

- 패킷 도착률이 링크 용량에 근접함에 따라 큐잉 지연이 커진다.
- 송신자는 버퍼 오버플로 때문에 버려진 패킷을 보상하기 위해 재전송을 수행해야 한다.
- 커다란 지연으로 인한 송신자의 불필요한 재전송은 라우터가 패킷의 불필요한 복사본들을 전송하는 데 링크 대역폭을 사용하는 원인이 된다.
- 패킷이 경로상에서 버려질 때, 버려지는 지점까지 패킷을 전송하는 데 사용된 상위 라우터에서 사용된 전송 용량은 낭비된 것이다.

혼잡 제어에 대한 종단 간의 접근 방식에서 네트워크 계층은 혼잡 제어 목적을 위해 트랜스포트 계층에게 어떤 직접적인 지원도 제공하지 않는다

네트워크에서 혼잡의 존재는 단지 관찰된 네트워크 동작(타임아웃, 3 중복 ACK)에 기초하여 종단 시스템이 추측해야 한다.

TCP 세그먼트 손실은 네트워크 혼잡의 발생 표시로 간주하고 TCP는 그에 따라서 윈도 크기를 줄인다.

```
💡 혼잡 제어에서 라우터들이 네트워크 안에서 혼잡 상태와 관련하여 송신자나 수신자 또는 모두에게 직접적인 피드백을 제공할 수도 있다.

라우터는 자신이 출력 링크에 제공할 수 있는 전송률을 송신자에게 명확히 알릴 수 있게 해준다.
```

<br />

### congestion window

네트워크가 받아들일 수 있는 데이터의 양을 의미한다.

`receive window` 값과 `congestion window`의 값 중 작은 값으로 설정하여 보내는 데이터의 양을 결정한다.

네트워크 혼잡에 따라 연결에 트래픽을 보내는 전송률을 각 송신자가 제한하도록 한다.

송신 측에서 동작하는 TCP 혼잡 제어 메커니즘은 추가적인 변수인 혼잡 윈도를 추적한다.

cwnd로 표시되는 혼잡 윈도는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 속도에 제약을 가한다.

즉, cwnd의 값을 조절하여, 송신자는 링크에 데이터를 전송하는 속도를 조절할 수 있다.

손실 이벤트가 발생할 때까지는 ACK가 도착함에 따라 전송률을 증가시키고, 손실 이벤트가 발생한 시점에서 전송률을 줄인다.

그러므로 TCP 송신자는 혼잡이 발생하는 시점까지 전송률을 증가시키고, 그 시점 이후부터는 줄인 후 다시 혼잡 시작이 발생했는지를 보기 위한 탐색을 시작한다.

- 네트워크가 잘 동작하면, cwnd를 linear하게 늘린다.
- 피드백이 안오는 순간, 네트워크 혼잡으로 판단하여 cwnd를 절반으로 줄인다.

  → 전송속도를 늘릴 때는 조심스럽고, 줄일 때는 크게 줄인다. (AIMD)

- 제일 처음에 데이터를 보낼 때는 cwnd를 얼마로 설정해야 할까?
  → 1MSS로 시작한다. (조심스럽게 시작, `MSS: Maximum segment size`)

<br />

### 슬로 스타트

슬로 스타트 상태에서는 cwnd 값을 1 MSS에서 시작하여, 한 전송 세그먼트가 첫 번째로 확인응답을 받을 때마다 1 MSS씩 증가한다.

그에 맞춰 하나의 MSS만큼 혼잡 윈도를 증가시킨다.

전송 측에서 패킷 loss를 감지하게 되는 경우는 두 가지가 있다.

1. timer expire
2. 3 duplicate ACK

3번의 중복 ACK는 특정 패킷이 운이 나빠 제대로 전송되지 않은 것이고, 이후 다른 패킷은 잘 전송되었다는 것을 알 수 있다.

하지만 타임아웃은 특정 패킷 이후로 데이터가 전송되지 않는다는 것을 의미하므로, 네트워크의 혼잡도는 타임아웃으로 인한 loss일 때 더 높다는 것을 알 수 있다.

그렇기에 타임아웃으로 인한 Loss일 때 cwnd를 1로 줄여서 다시 슬로 스타트를 시작하며 슬로 스타트 임계값인 ssthresh를 cwnd/2 (혼잡이 검출되었을 시점에서의 혼잡 윈도 값의 반)로 정한다.

cwnd 값이 ssthresh와 같아지면, 슬로 스타트는 종료되고 TCP는 혼잡 회피 모드로 들어가 cwnd 값이 linear하게 증가하게 된다.

3 duplicate ACK일 경우에는 cwnd를 절반으로 줄인 후 다시 시작한다. 즉, 빠른 재전송을 수행하여 빠른 회복 상태로 들어간다. (TCP Reno의 경우 해당 시점의 절반 cwnd부터 다시 AIMD로 증가)

<br />

### AIMD (Additive Increse/Multicative Decrease)

우리말로 직역하면 `합 증가/ 곱 감소` 방식이다.

- 처음에 패킷을 하나씩 보내고 문제없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송한다.
- 만약 전송에 실패하면 윈도우 크기를 반으로 줄인다.
- 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다.

<p align="center">
  <img src="https://github.com/user-attachments/assets/a48ebd61-91cd-4832-b8de-15a5522c969e" width="50%"/>
</p>

<br />

### 혼잡 회피

혼잡 회피 상태로 들어가는 시점에서 cwnd의 값은 대략 혼잡이 마지막으로 발견된 시점에서의 값의 반이 된다.

그러므로 RTT마다 cwnd 값을 두배로 하기보다는 TCP는 좀 더 보수적인 접근법을 채택하여 RTT마다 하나의 MSS만큼 cwnd 값을 증가시킨다.

<br />

### 빠른 회복 (Fast Recovery)

`빠른 회복`은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 방법을 적용하면 혼잡 상황을 한번 겪고 나서부터는 `AIMD` 방식으로 동작한다.

<br />

## TCP 혼잡 제어 정책

### TCP Tahoe

`TCP Tahoe`는 처음에는 `Slow Start`를 사용하다가 임계점에 도달하면 `AIMD` 방식을 사용한다. 그러다가 `3 ACK Duplicated` 또는 `타임아웃`이 발생하면 혼잡이라고 판단하여 임계점은 혼잡이 발생한 윈도우 크기의 절반으로, 윈도우 크기는 1로 줄인다.

<p align="center">
  <img src="https://github.com/user-attachments/assets/b76bac09-8ef9-4ddd-8ec5-87ee904b191c" width="50%"/>
</p>

위 그래프에서 청록색 선은 송신 측의 혼잡 윈도우 크기를, 굵은 검정선은 ssthresh 값을 보여주고 있다.

이 방식은 혼잡 이후 Slow Start 구간에서 윈도우 크기를 키울 때 너무 오래걸린다는 단점이 있다. 1부터 키워나가야 하기 때문이다.

그래서 나온 방법이 `빠른 회복` 방식을 활용한 `TCP Reno` 이다.

<br />

### TCP Reno

`TCP Tahoe`와 마찬가지로 Slow Start로 시작하여 임계점을 넘어가면 `AIMD` 방식으로 변경한다.

`TCP Tahoe`와의 차이점은 바로 `3 ACK Duplicaed`와 `타임아웃`을 구분한다는 점이다. `TCP Reno`는 `3 ACK Duplicated`가 발생하면 `빠른회복` 방식을 사용한다.

즉, 윈도우 크기를 1로 줄이는 것이 아니라 반으로 줄이고 윈도우 크기를 선형적으로 증가시킨다. 그리고 임계점을 줄어든 윈도우 값으로 설정한다.

<p align="center">
  <img src="https://github.com/user-attachments/assets/2615114b-66e7-4a51-a956-08df3d7f4f68" width="50%"/>
</p>

만약, `타임아웃`이 발생하면 `TCP Tahoe`와 마찬가지로 윈도우 크기를 1로 줄이고 Slow Start를 진행한다. 이때는 임계점을 변경하지 않는다.

<br />

### TCP throughput

단위시간당 데이터 전송 속도

TCP 처리율은 네트워크의 상황에 따라 달라진다.

즉, 송신측과 수신측이 결정하는게 아니라 네트워크에서 결정하게 된다.

UDP의 전송속도는 애플리케이션이 결정한다.

<br />

### TCP 큐빅

전송 속도를 절반으로 줄인 다음 시간이 지남에 따라 천천히 증가시키는 것은 지나치게 신중한 일일 수 있다.

패킷 손실이 발생한 혼잡한 링크의 상태가 많이 변경되지 않은 경우 전송 속도를 더 빠르게 높여 손실 전 전송 속도에 근접한 다음 대역폭을 신중하게 조사하는 것이좋을 것이다.

이것이 TCP 큐빅의 특징이다.

큐빅은 손실 전 속도인 W에 가까워지도록 TCP의 전송 속도를 빠르게 증가시킨 다음, W에 가까워지면 대역폭을 조심스럽게 탐지한다.

<p align="center">
  <img src="https://github.com/user-attachments/assets/3b2fbb58-1f69-455d-ab32-1f88c66e7a3c" width="50%"/>
</p>

congestion 상황은 짧은 시간내에 바뀌지 않기 때문에 해소된 후에 빠르게 다시 최대 throughput을 점유할 수 있는 방법이다.

<br />

## 명시적 혼잡 알림

이전엔 TCP 송신자가 네트워크에서 명시적인 혼잡 표시를 수신하지 않는 대신, 관찰된 패킷 손실을 통해 혼잡을 추론했다.

`명시적 혼잡 알림`은 네트워크 계층에서 IP 데이터그램 헤더의 서비스 유형 필드에 있는 2비트가 ECN에 사용되어 라우터가 정체를 겪고 있음을 TCP 송-수신자에게 알려주는 것이다.

<br />

### ECN

ECN 비트의 한 설정은 라우터가 정체를 겪고 있음을 나타내기 위해 라우터에서 사용된다.

이 혼잡 표시는 표시된 IP 데이터그램에서 목적지 호스트로 전달되어 송신 호스트에게 알린다.

ECN 비트의 두번째 설정은 발신 호스트가 라우터에게 송신자와 수신자가 ECN을 사용할 수있음을 알리고, 이에 따라 ECN으로 표시된 네트워크 혼잡에 대한 응답으로 조치를 취할 수 있음을 알리는 데 사용된다.

<p align="center">
  <img src="https://github.com/user-attachments/assets/2116b1bd-e85e-404d-afdb-8f69aa247707" width="50%"/>
</p>

수신 호스트의 TCP가 수신 데이터그램을 통해 ECN 혼잡 알림 표시를 수신하면, 수신 호스트의 TCP는 수신자-송신자 TCP ACK 세그먼트의 ECE(Explicit Congestion Notification Echo)비트를 설정하여 송신 호스트의 TCP에 혼잡 표시를 알린다.

TCP 송신자는 빠른 재전송을 사용하여 손실된 세그먼트에 반응하는 것 처럼, 혼잡 윈도를 절반으로 줄여 혼잡 알림 표시가 있는 ACK에 반응하고 다음 전송되는 TCP 수신자 세그먼트 헤더에 CWR(Congestion Window Reduced) 비트를 1로 설정한다.

송신자는 이를 통해 패킷 손실 이전에 더 일찍 전송 속도를 줄일 수 있으므로 값비싼 패킷 손실 및 재전송을 피할 수 있게 된다.

<br />

## 자연 기반 혼잡 제어

송신자가 측정한 처리량이 혼잡하지 않을 때의 처리량보다 현저히 낮으면 경로가 혼잡하고 TCP 베가스 송신자는 전송 속도를 낮추게 된다.

TCP 베가스는 TCP 송신자가 파이프를 가득 채우되 그 이상으로 채우지 않도록 해야 한다는 직관적인 원칙하에 동작한다.

<br />

## 공평성

이상적인 시나리오에선 모든 TCP가 대역폭을 똑같이 공유한다.

하지만, 현실에선 클라이언트-서버 애플리케이션들은 링크 대역폭의 각기 다른 양을 얻을 수 있다.

특히 여러 연결이 공통의 병목 링크를 공유할 때, 더 작은 RTT를 갖는 세션은 대역폭이 좀 더 빠르게 비워지므로 링크에서 가용한 대역폭을 점유할 수 있다.

그래서 큰 RTT를 갖는 연결보다 더 높은 처리율을 갖는다.
