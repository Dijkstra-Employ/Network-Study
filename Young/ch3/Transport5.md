## 연결지향형 트랜스포트 : TCP
TCP는 신뢰적인 데이터 전송 원칙을 따르기 위해서 오류 검출, 재저농, 누적확인응답, 타이머, 순서 번호와 확인 응답 번호를 사용하고 있다. 

### 1. TCP 연결
TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에 보내기 전에 두 프로세스가 먼저 서로 **연결되어야 하는 연결지향형**이다. 즉, 데이터 전송을 보장하는 파라미터들을 설정하기 위해 **사전 세그먼트를 보내야 한다**. TCP 연결 설정의 일부로서, **연결의 양단은 TCP 연결과 연관된 많은 TCP 상태 변수들을 초기화한다.**

TCP 연결은 회선 교환 네트워크에서와 같이 종단 간의 TDM이나 FDM이 아니다. 즉, 특정한 경로를 설정하고 이 통로로 통신하는 동안 독점적으로 회로를 사용하는 것이 아니다. 대신 **연결은 두 통신 종단 시스템의 TCP에 존재하는 상태(시퀀스 번호, 확인 응답 번호 등)를 공유하는 논리적인 것이다.** 또한 라우터 같은 중간 네트워크 요소에서는 전혀 동작하지 않는다.(TCP 연결을 감지 못함)

TCP 연결은 **전이중 서비스를 제공**한다. 즉, A->B로 흐르는 동시에 B->A로 흐를 수 있다. 또한, **단일 송신자와 단일 수신자의 점대점 방식**이다. 

다음은 TCP 연결이 어떻게 되는지 살펴보자.
먼저 연결이 되고자 원하여 연결을 초기화하는 프로세스를 **클라이언트 프로세스**, 다른 프로세스를 **서버 프로세스**라고 한다. 클라이언트 애플리케이션 프로세스에서는 서버 프로세스와 연결되고 싶다고 **TCP 클라이언트**에게 알린다. 
```
clientSocket.connect((serverName, serverPort))
```
이렇게 됐다면 클라이언트의 트랜스포트 계층은 서버 TCP와 TCP 연결을 진행한다. 
연결 진행은 클라이언트가 특별한 TCP 세그먼트를 보내면 서버가 두 번쨰 특별한 TCP 세그먼트로 응답하고, 마지막으로 클라이언트가 세 번째 특별한 세그먼트로 응답하는 것이다. 마지막 세그먼틍는 페이로드를 포함할 수 있다.
=> **세 방향 핸드쉐이크**

연결 이후를 생각해보자.
클라이언트 프로세스는 소켓을 통해 데이터 스트림을 전달하고, TCP가 이를 전달 받는다. TCP는 초기 세 방향 핸드쉐이크 시 만들었던 **송신 버퍼**로 데이터를 보낸다. 그리고, TCP는 송신 버퍼에서 데이터 묶음을 만들어 네트워크로 보낸다.(세그먼트) 세그먼트로 모아 보낼 수 있는 초대 데이터 양은 **최대 세그먼트 크기(MMS)로 제한**한다. MMS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(MTU)에 의해 일단 결정되고, 그런 후에 TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/5d374d96-1844-4bca-aa7f-d1202f7761e6/image.png)

TCP 연결은 한쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결의 집합으로 이루어진다는 사실을 알아야 한다. 

### 2. TCP 세그먼트 구조
TCP 세그먼트는 헤더와 데이터 필드로 구성되어 있다. 여기서 데이터 필드는 MSS에 의해 제한된다. TCP는 웹 문서의 이미지 같은 큰 파일을 전송할 때 일반적으로 MSS 크기로 파일을 분철한다. 그러나, 많은 _대화식 애플리케이션은 MSS보다 작은 양의 데이터를 전송한다._

![](https://velog.velcdn.com/images/choiyoung6609/post/21b32419-153b-4ce1-83c2-7bab1f3d8128/image.png)

TCP의 헤더는 당연하게도 다중화와 역다중화를 위한 **출발지와 목적지 포트 번호**와 **체크섬 필드**를 포함한다.
- 순서 번호 필드와 확인 응답 필드 : 신뢰적인 데이터 전송 서비스 구현을 위해 필요
- 16비트 수신 윈도 : 흐름 제어에 사용
- 헤더 길이 필드 : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다. TCP 헤더는 옵션 필드 때문에 _가변적인 길이_가 될 수 있다.
- 선택적이고 가변적인 길이의 옵션 필드 : 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나, 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 사용된다.
- 플래그 필드 : ACK 필드는 확인 응답에 있는 값이 유용한지 가리킨다. RST, SYN, FIN 비트는 연결 설정과 해제에 사용된다. PSH 비트가 설정될 때는 수신자가 데이터를 **상위 계층에 즉시 전달해야 한는 것**을 의미한다. 마지막으로, URG 비트는 송신 측 상위 계층 개체가 **낀급으로 표시하는 데이터**임을 의미하는 것이다. 그리고 이 비트의 마지막 바이트의 위치는 16비트의 **긴급 데이터 포인터 필드**가 가리킨다. 

> **순서 번호와 확인 응답 번호**

TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지는 **순서 번호 필드**와 **확인응답 번호 필드**이다. 
TCP는 데이터를 단순히 순서대로 정렬되어 있는 바이트 스트림으로 본다. 따라서, 순서 번호 사용은 순서 번호가 일련의 세그먼트에 대애서가 아니라 전송된 바이트 스트림에 대해서라는 관점을 반영한 것이다. **세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.**

다음은 확인응답 번호이다. TCP는 전이중 방식으로 호스트 B로부터 도착한 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 갖는다. **호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호다.** 또한, TCP는 첫 번째로 손실된 바이트 전까지 받은 데이터를 누적하여 확인 응답한다. 따라서 **누적응답을 제공한다고 말한다.**<특정 바이트까지의 모든 데이터가 성공적으로 수신되었음을 한 번에 확인해주는 방식>

여기서 문제는 순서가 바뀐 세그먼트를 수신받았을 때 TCP는 어떻게 행동할까? 이다. 이에 TCP RFC는 어떠한 규칙도 부여하지 않고, TCP 구현 개발자에게 맡겼는데 2가지 선택이 존재한다.
1) 순서가 바뀐 세그먼트를 즉시 버린다.
2) 순서가 바뀐 데이터를 보유하고 빈 공간에 잃어버린 데이터를 기다린다.
=> 2번 방식이 대역폭 관점에서 **효율적이며**, 실제로도 취하는 방식이다.


### 텔넷: 순서번호와 응답확인 번호 사례연구
RFC 854에서 정의된 텔넷은 원격 로그인을 위해 사용되는 애플리케이션으로 TCP 상에서 실행된다.
![](https://velog.velcdn.com/images/choiyoung6609/post/a20b2ff1-ae97-4810-bdc2-b8efb9873561/image.png)

위의 그림은 클라이언트에서 사용자가 입력한 문자가 원격 호스트에게 송신되고 원격 호스트에서 각 문자의 송신자에게 반송하는 것이다. (echo back : 송신자가 보는 문자는 이미 원격 사이트에서 수신되고 처리되었음을 의미)

그림처럼 초기 순서 번호가 클라이언트와 서버에 대해 각각 42, 79라고 가정한다. 또한, 확인응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호이다. 따라서, 어떤 데이터도 송신되기 전에 클라이언트는 서버의 첫 번째 바이트 번호인 79를, 서버는 클라이언트의 첫 번째 바이트 번호인 42를 기다리고 있다. 

첫 번째 세그먼트에서는 데이터 필드에서 C 문자를 가지며, 순서 번호 필드가 42이다. 또한, 아직 서버로부터 어떠한 데이터를 가지지 못했으므로 확인응답 번호 필드에 79를 가진다.

두 번째 서버에서 클라이언트로 송신되는데 두 가지 목적을 갖는다. 첫째, **수신하는 서버에게 데이터에 대한 확인응답을 제공한다.** 이때, 서버는 클라이언트에게 43을 ACK에 넣음으로써, 42를 제대로 수신했고, 43을 기다리고 있다는 것을 말해주는 것이다. 그리고 두 번째 목적은 **문자 C가 반향되도록 하는 것이다.** 이때, C는 현재 순서 번호인 79를 갖는다. 이것이 서버가 보내는 데이터의 맨 첫 번째 바이트이다. 즉, 클라이언트/서버에 대한 확인응답을 데이터를 운반하는 세그먼트 안에 전달하는 **피기백(piggybacked) 방식을 사용**하는 것이다. 

세 번째 세그먼트는 클라이언트에서 서버로 송신되는데 **서버로부터 수신된 데이터에 대한 확인응답**이다. 이때는 전달할 데이터가 없기 때문에 빈 데이터 필드를 갖는다. 즉, 피기백되지 않는다. 또한, 클라이언트가 앞에서 79라는 순서번호를 가지고 송신했기 때문에 앞으로 80으로 시작하는 바이트를 기다린다.


### 3. 왕복 시간(RTT) 예측과 타임아웃
rdt 프로토콜 처럼 TCP가 손실 세그먼트에 대한 대처를 하기 위해서는 **타이머와 재전송 메커니즘**이 필요하다. 그러나, 이 메커니즘을 실제 TCP에 구현할 때는 여러 상황을 고려해야 한다. 
- 타임아웃의 시간은 얼마 정도로 설정해야 할까?
- RTT는 처음에 어떻게 측정할까?
- 타이머는 승인되지 않은 모든 세그먼트와 연결되어야 할까?

> #### 왕복 시간 예측

먼저 왕복 시간을 어떻게 예측하는지 생각하며넛 TCP 타이머에 대해 공부해보자. **SampleRTT**라고 불리는 세그먼트에 대한 RTT 샘플은 송신된 시간부터 긍정응답이 도착한 시간까지의 길이이다. 모든 전송된 세그먼트에 대해 SampleRTT를 측정하는 것은 아니고 대부분의 TCP는 **한 번에 하나의 SampleRTT 측정만을 시행한다.** 즉, 여러 세그먼트가 동시에 전송되더라도 하나의 세그먼트에 대해서만 RTT를 측정하는 것이다. 이는 대략 왕복 시간마다 SampleRTT의 새로운 값을 얻게 한다. 또한, 왜곡 등의 이유로 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정한다.

SampleRTT 값은 순간순간의 라우터 혼잡과 종단 시스템에서의 부하 변화 대문에 세그먼트마다 다르다.(뷸규칙적) 따라서 RTT를 추정하기 위해서는 SampleRTT의 평균값을 구해야 한다.(EstimatedRTT)

```
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT
```

EstimatedRTT의 값은 이전 EstimatedRTT의 값과 이번의 SampleRTT 값을 가중한 것이다.(권장 a는 0.125) EstimatedRTT는 SampleRTT 값의 가중 균으로 최근 값에 더 높은 가중치를 주는 것이다. 통계에서 이런 평균을 **지수적 가중 이동 평균**이라고 부른다.

RTT의 예측 외에도 RTT의 변화율을 측정하는 것도 매우 유용하다. RTT의 변화율을 의미하는 DevRTT를 SampleRTT가 EstimatedRTT로부터 얼마나 많이 벗어나는지에 대한 예측으로 정의한다.

```
DevRTT = (1 - b) * DevRTT + b * 절대값(SampleRTT - EstimatedRTT)
```
DevRTT는 똑같은 지수적 가동 이동 평균이다. 만약 SampleRTT값이 어떠한 변화도 없다면 작을 것이고, 그렇지 않다면 DevRTT가 클 것이다.(권장 b는 0.25)

> #### 재전송 타임아웃 주기의 설정과 관리

주어진 EstimatedRtt와 DevRTT 값에서 TCP 타임아웃 주기에 어떤 값이 사용되는 걸까? **기본적으로 TCP 타임아웃 값은 EstimatedRTT보다 크거나 같아야 한다.**(재전송 방지) 그러나, 너무 값이 커지게 되면 _즉각적인 반응을 할 수 없어진다_(전송 지연). 이 때문에 약간의 여유값을 넣어야 하는데 변동률이 클 수록 여유값이 늘어나고, 변동률이 작을 수록 여윳값도 작아진다. 따라서 다음과 같은 식을 사용하여 TimeoutInterval을 구한다.

```
TimeoutInterval = EstimatedRTT + 4 * DevRTT
```

초기 TimeoutInterval은 1초를 권하며 타임아웃 이벤트가 발생했다면 _후속 세그먼트의 조기 타임아웃을 피하기 위해 TimeoutInterval을 두 배로 설정_한다. 이후 세그먼트가 정상저긍로 수신되고 EstimatedRTT가 수정됐을 때, 정상적으로 TimeoutInterval이 위의 식을 통해 계산된다.


### 4. 신뢰적인 데이터 전송
인터넷에서 IP 계층은 비신뢰적이다. 그러나, TCP는 이러한 IP의 비신뢰적인 최선형 서비스에서 **신뢰적인 데이터 전송 서비스**를 제공해야 한다. 
=> NO 손상, NO 손실, 순서 유지 기능

사실 전송되었지만, 확인응답을 받지 못한 세그먼트에 대해 타이머와 한 쌍을 이루도록 하는 것이 개념상 가장 쉽다. 그러나, 타이머 관리는 상당한 **오버헤드가 생기므로** 오직 **단일 재전송 타이머를 사용**한다. 

TCP가 **어떻게 신뢰적인 데이터 전송을 제공하는지 2개의 점진적인 단계**로 알아보자
1) 손실 세그먼트를 복구하기 위해 타임아웃만을 이용하는 TCP 송신자.
2) 타임아웃에 중복확인응답을 포함하여 중복된 값이 없도록 하는 것.


- **아주 간소한 TCP 송신자에 대해 설명해보자(1)**
TCP의 전송과 재전송에 대해 세 가지 주요 이벤트가 있다. 바로, **상위 계층으로부터 데이터 수신될 때, 타이머 타임아웃, ACK 수신**이다. 
	**첫 번째 이벤트가 발생했을 때**, 각 세그먼트는 데이터를 받고 캡슐화하여 IP에 넘긴다. 이때, 순서 번호는 첫 번째 데이터 바이트의 바이트 열 번호이다. 또한, 타이머가 다른 곳에서 실행 중이지 않다면 타이머를 실행한다.
    **두 번째 이벤트가 발생했을 때**, 타임아웃을 일으킨 세그먼트를 재전송하여 이벤트를 처리한다. 그리고 이때, 타이머를 다시 시작한다. 
    **세 번째 이벤트가 발생했을 때**, 수신 확인응답 세그먼트(ACK)를 수신했을 때이다. 이때, TCP는 변수 sendBase와 ACK의 변수 y값을 확인한다. TCP는 **누적 확인응답을 사용하기 때문에 y가 sendBase이면, 이미 수신자에게는 y까지의 데이터가 전송된 것이다.**즉, ACK는 확인응답이 안 된 하나 이상의 세그먼트들을 확인시켜주면서 송신자는 자신의 Sendbase를 갱신할 수 있게 된다.(y값으로 갱신). **또한, 확인 응답 안 된 세그먼트들이 존재한다면 타이머를 다시 시작한다. **

#### 몇 가지 흥미로운 시나리오

