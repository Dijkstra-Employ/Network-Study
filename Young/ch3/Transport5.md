## 연결지향형 트랜스포트 : TCP
TCP는 신뢰적인 데이터 전송 원칙을 따르기 위해서 오류 검출, 재저농, 누적확인응답, 타이머, 순서 번호와 확인 응답 번호를 사용하고 있다. 

### 1. TCP 연결
TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에 보내기 전에 두 프로세스가 먼저 서로 **연결되어야 하는 연결지향형**이다. 즉, 데이터 전송을 보장하는 파라미터들을 설정하기 위해 **사전 세그먼트를 보내야 한다**. TCP 연결 설정의 일부로서, **연결의 양단은 TCP 연결과 연관된 많은 TCP 상태 변수들을 초기화한다.**

TCP 연결은 회선 교환 네트워크에서와 같이 종단 간의 TDM이나 FDM이 아니다. 즉, 특정한 경로를 설정하고 이 통로로 통신하는 동안 독점적으로 회로를 사용하는 것이 아니다. 대신 **연결은 두 통신 종단 시스템의 TCP에 존재하는 상태(시퀀스 번호, 확인 응답 번호 등)를 공유하는 논리적인 것이다.** 또한 라우터 같은 중간 네트워크 요소에서는 전혀 동작하지 않는다.(TCP 연결을 감지 못함)

TCP 연결은 **전이중 서비스를 제공**한다. 즉, A->B로 흐르는 동시에 B->A로 흐를 수 있다. 또한, **단일 송신자와 단일 수신자의 점대점 방식**이다. 

다음은 TCP 연결이 어떻게 되는지 살펴보자.
먼저 연결이 되고자 원하여 연결을 초기화하는 프로세스를 **클라이언트 프로세스**, 다른 프로세스를 **서버 프로세스**라고 한다. 클라이언트 애플리케이션 프로세스에서는 서버 프로세스와 연결되고 싶다고 **TCP 클라이언트**에게 알린다. 
```
clientSocket.connect((serverName, serverPort))
```
이렇게 됐다면 클라이언트의 트랜스포트 계층은 서버 TCP와 TCP 연결을 진행한다. 
연결 진행은 클라이언트가 특별한 TCP 세그먼트를 보내면 서버가 두 번쨰 특별한 TCP 세그먼트로 응답하고, 마지막으로 클라이언트가 세 번째 특별한 세그먼트로 응답하는 것이다. 마지막 세그먼틍는 페이로드를 포함할 수 있다.
=> **세 방향 핸드쉐이크**

연결 이후를 생각해보자.
클라이언트 프로세스는 소켓을 통해 데이터 스트림을 전달하고, TCP가 이를 전달 받는다. TCP는 초기 세 방향 핸드쉐이크 시 만들었던 **송신 버퍼**로 데이터를 보낸다. 그리고, TCP는 송신 버퍼에서 데이터 묶음을 만들어 네트워크로 보낸다.(세그먼트) 세그먼트로 모아 보낼 수 있는 초대 데이터 양은 **최대 세그먼트 크기(MMS)로 제한**한다. MMS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(MTU)에 의해 일단 결정되고, 그런 후에 TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/5d374d96-1844-4bca-aa7f-d1202f7761e6/image.png)

TCP 연결은 한쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결의 집합으로 이루어진다는 사실을 알아야 한다. 

### 2. TCP 세그먼트 구조
TCP 세그먼트는 헤더와 데이터 필드로 구성되어 있다. 여기서 데이터 필드는 MSS에 의해 제한된다. TCP는 웹 문서의 이미지 같은 큰 파일을 전송할 때 일반적으로 MSS 크기로 파일을 분철한다. 그러나, 많은 _대화식 애플리케이션은 MSS보다 작은 양의 데이터를 전송한다._

![](https://velog.velcdn.com/images/choiyoung6609/post/21b32419-153b-4ce1-83c2-7bab1f3d8128/image.png)

TCP의 헤더는 당연하게도 다중화와 역다중화를 위한 **출발지와 목적지 포트 번호**와 **체크섬 필드**를 포함한다.
- 순서 번호 필드와 확인 응답 필드 : 신뢰적인 데이터 전송 서비스 구현을 위해 필요
- 16비트 수신 윈도 : 흐름 제어에 사용
- 헤더 길이 필드 : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다. TCP 헤더는 옵션 필드 때문에 _가변적인 길이_가 될 수 있다.
- 선택적이고 가변적인 길이의 옵션 필드 : 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나, 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 사용된다.
- 플래그 필드 : ACK 필드는 확인 응답에 있는 값이 유용한지 가리킨다. RST, SYN, FIN 비트는 연결 설정과 해제에 사용된다. PSH 비트가 설정될 때는 수신자가 데이터를 **상위 계층에 즉시 전달해야 한는 것**을 의미한다. 마지막으로, URG 비트는 송신 측 상위 계층 개체가 **낀급으로 표시하는 데이터**임을 의미하는 것이다. 그리고 이 비트의 마지막 바이트의 위치는 16비트의 **긴급 데이터 포인터 필드**가 가리킨다. 

> **순서 번호와 확인 응답 번호**

TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지는 **순서 번호 필드**와 **확인응답 번호 필드**이다. 
TCP는 데이터를 단순히 순서대로 정렬되어 있는 바이트 스트림으로 본다. 따라서, 순서 번호 사용은 순서 번호가 일련의 세그먼트에 대애서가 아니라 전송된 바이트 스트림에 대해서라는 관점을 반영한 것이다. **세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.**

다음은 확인응답 번호이다. TCP는 전이중 방식으로 호스트 B로부터 도착한 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 갖는다. **호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호다.** 또한, TCP는 첫 번째로 손실된 바이트 전까지 받은 데이터를 누적하여 확인 응답한다. 따라서 **누적응답을 제공한다고 말한다.**<특정 바이트까지의 모든 데이터가 성공적으로 수신되었음을 한 번에 확인해주는 방식>

여기서 문제는 순서가 바뀐 세그먼트를 수신받았을 때 TCP는 어떻게 행동할까? 이다. 이에 TCP RFC는 어떠한 규칙도 부여하지 않고, TCP 구현 개발자에게 맡겼는데 2가지 선택이 존재한다.
1) 순서가 바뀐 세그먼트를 즉시 버린다.
2) 순서가 바뀐 데이터를 보유하고 빈 공간에 잃어버린 데이터를 기다린다.
=> 2번 방식이 대역폭 관점에서 **효율적이며**, 실제로도 취하는 방식이다.


### 텔넷: 순서번호와 응답확인 번호 사례연구
RFC 854에서 정의된 텔넷은 원격 로그인을 위해 사용되는 애플리케이션으로 TCP 상에서 실행된다.
![](https://velog.velcdn.com/images/choiyoung6609/post/a20b2ff1-ae97-4810-bdc2-b8efb9873561/image.png)

위의 그림은 클라이언트에서 사용자가 입력한 문자가 원격 호스트에게 송신되고 원격 호스트에서 각 문자의 송신자에게 반송하는 것이다. (echo back : 송신자가 보는 문자는 이미 원격 사이트에서 수신되고 처리되었음을 의미)

그림처럼 초기 순서 번호가 클라이언트와 서버에 대해 각각 42, 79라고 가정한다. 또한, 확인응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호이다. 따라서, 어떤 데이터도 송신되기 전에 클라이언트는 서버의 첫 번째 바이트 번호인 79를, 서버는 클라이언트의 첫 번째 바이트 번호인 42를 기다리고 있다. 

첫 번째 세그먼트에서는 데이터 필드에서 C 문자를 가지며, 순서 번호 필드가 42이다. 또한, 아직 서버로부터 어떠한 데이터를 가지지 못했으므로 확인응답 번호 필드에 79를 가진다.

두 번째 서버에서 클라이언트로 송신되는데 두 가지 목적을 갖는다. 첫째, **수신하는 서버에게 데이터에 대한 확인응답을 제공한다.** 이때, 서버는 클라이언트에게 43을 ACK에 넣음으로써, 42를 제대로 수신했고, 43을 기다리고 있다는 것을 말해주는 것이다. 그리고 두 번째 목적은 **문자 C가 반향되도록 하는 것이다.** 이때, C는 현재 순서 번호인 79를 갖는다. 이것이 서버가 보내는 데이터의 맨 첫 번째 바이트이다. 즉, 클라이언트/서버에 대한 확인응답을 데이터를 운반하는 세그먼트 안에 전달하는 **피기백(piggybacked) 방식을 사용**하는 것이다. 

세 번째 세그먼트는 클라이언트에서 서버로 송신되는데 **서버로부터 수신된 데이터에 대한 확인응답**이다. 이때는 전달할 데이터가 없기 때문에 빈 데이터 필드를 갖는다. 즉, 피기백되지 않는다. 또한, 클라이언트가 앞에서 79라는 순서번호를 가지고 송신했기 때문에 앞으로 80으로 시작하는 바이트를 기다린다.


### 3. 왕복 시간(RTT) 예측과 타임아웃
rdt 프로토콜 처럼 TCP가 손실 세그먼트에 대한 대처를 하기 위해서는 **타이머와 재전송 메커니즘**이 필요하다. 그러나, 이 메커니즘을 실제 TCP에 구현할 때는 여러 상황을 고려해야 한다. 
- 타임아웃의 시간은 얼마 정도로 설정해야 할까?
- RTT는 처음에 어떻게 측정할까?
- 타이머는 승인되지 않은 모든 세그먼트와 연결되어야 할까?

> #### 왕복 시간 예측

먼저 왕복 시간을 어떻게 예측하는지 생각하며넛 TCP 타이머에 대해 공부해보자. **SampleRTT**라고 불리는 세그먼트에 대한 RTT 샘플은 송신된 시간부터 긍정응답이 도착한 시간까지의 길이이다. 모든 전송된 세그먼트에 대해 SampleRTT를 측정하는 것은 아니고 대부분의 TCP는 **한 번에 하나의 SampleRTT 측정만을 시행한다.** 즉, 여러 세그먼트가 동시에 전송되더라도 하나의 세그먼트에 대해서만 RTT를 측정하는 것이다. 이는 대략 왕복 시간마다 SampleRTT의 새로운 값을 얻게 한다. 또한, 왜곡 등의 이유로 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정한다.

SampleRTT 값은 순간순간의 라우터 혼잡과 종단 시스템에서의 부하 변화 대문에 세그먼트마다 다르다.(뷸규칙적) 따라서 RTT를 추정하기 위해서는 SampleRTT의 평균값을 구해야 한다.(EstimatedRTT)

```
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT
```

EstimatedRTT의 값은 이전 EstimatedRTT의 값과 이번의 SampleRTT 값을 가중한 것이다.(권장 a는 0.125) EstimatedRTT는 SampleRTT 값의 가중 균으로 최근 값에 더 높은 가중치를 주는 것이다. 통계에서 이런 평균을 **지수적 가중 이동 평균**이라고 부른다.

RTT의 예측 외에도 RTT의 변화율을 측정하는 것도 매우 유용하다. RTT의 변화율을 의미하는 DevRTT를 SampleRTT가 EstimatedRTT로부터 얼마나 많이 벗어나는지에 대한 예측으로 정의한다.

```
DevRTT = (1 - b) * DevRTT + b * 절대값(SampleRTT - EstimatedRTT)
```
DevRTT는 똑같은 지수적 가동 이동 평균이다. 만약 SampleRTT값이 어떠한 변화도 없다면 작을 것이고, 그렇지 않다면 DevRTT가 클 것이다.(권장 b는 0.25)

> #### 재전송 타임아웃 주기의 설정과 관리

주어진 EstimatedRtt와 DevRTT 값에서 TCP 타임아웃 주기에 어떤 값이 사용되는 걸까? **기본적으로 TCP 타임아웃 값은 EstimatedRTT보다 크거나 같아야 한다.**(재전송 방지) 그러나, 너무 값이 커지게 되면 _즉각적인 반응을 할 수 없어진다_(전송 지연). 이 때문에 약간의 여유값을 넣어야 하는데 변동률이 클 수록 여유값이 늘어나고, 변동률이 작을 수록 여윳값도 작아진다. 따라서 다음과 같은 식을 사용하여 TimeoutInterval을 구한다.

```
TimeoutInterval = EstimatedRTT + 4 * DevRTT
```

초기 TimeoutInterval은 1초를 권하며 타임아웃 이벤트가 발생했다면 _후속 세그먼트의 조기 타임아웃을 피하기 위해 TimeoutInterval을 두 배로 설정_한다. 이후 세그먼트가 정상저긍로 수신되고 EstimatedRTT가 수정됐을 때, 정상적으로 TimeoutInterval이 위의 식을 통해 계산된다.


### 4. 신뢰적인 데이터 전송
인터넷에서 IP 계층은 비신뢰적이다. 그러나, TCP는 이러한 IP의 비신뢰적인 최선형 서비스에서 **신뢰적인 데이터 전송 서비스**를 제공해야 한다. 
=> NO 손상, NO 손실, 순서 유지 기능

사실 전송되었지만, 확인응답을 받지 못한 세그먼트에 대해 타이머와 한 쌍을 이루도록 하는 것이 개념상 가장 쉽다. 그러나, 타이머 관리는 상당한 **오버헤드가 생기므로** 오직 **단일 재전송 타이머를 사용**한다. 

TCP가 **어떻게 신뢰적인 데이터 전송을 제공하는지 2개의 점진적인 단계**로 알아보자
1) 손실 세그먼트를 복구하기 위해 타임아웃만을 이용하는 TCP 송신자.
2) 타임아웃에 중복확인응답을 포함하여 중복된 값이 없도록 하는 것.


- **아주 간소한 TCP 송신자에 대해 설명해보자(1)**
TCP의 전송과 재전송에 대해 세 가지 주요 이벤트가 있다. 바로, **상위 계층으로부터 데이터 수신될 때, 타이머 타임아웃, ACK 수신**이다. 
	**첫 번째 이벤트가 발생했을 때**, 각 세그먼트는 데이터를 받고 캡슐화하여 IP에 넘긴다. 이때, 순서 번호는 첫 번째 데이터 바이트의 바이트 열 번호이다. 또한, 타이머가 다른 곳에서 실행 중이지 않다면 타이머를 실행한다.
    **두 번째 이벤트가 발생했을 때**, 타임아웃을 일으킨 세그먼트를 재전송하여 이벤트를 처리한다. 그리고 이때, 타이머를 다시 시작한다. 
    **세 번째 이벤트가 발생했을 때**, 수신 확인응답 세그먼트(ACK)를 수신했을 때이다. 이때, TCP는 변수 sendBase와 ACK의 변수 y값을 확인한다. TCP는 **누적 확인응답을 사용하기 때문에 y가 sendBase이면, 이미 수신자에게는 y까지의 데이터가 전송된 것이다.**즉, ACK는 확인응답이 안 된 하나 이상의 세그먼트들을 확인시켜주면서 송신자는 자신의 Sendbase를 갱신할 수 있게 된다.(y값으로 갱신). **또한, 확인 응답 안 된 세그먼트들이 존재한다면 타이머를 다시 시작한다. **

#### 몇 가지 흥미로운 시나리오
TCP 프로토콜이 어떤 식으로 작동하는지 여러 시나리오를 통해서 알아보자.

![](https://velog.velcdn.com/images/choiyoung6609/post/72496b57-4b33-4a68-9937-576f2ae87f2d/image.png)

첫 번째 시나리오는 ACK를 잃어버렸을 때 발생하는 시나리오이다. 호스트 A에서 세그먼트를 보내지만 중간에 긍정 확인응답이 손실되어 타임아웃이 일어났다. 타임아웃 이후에 다시 똑같은 세그먼트를 보내게 되고, 호스트 B에서는 이미 전송받은 세그먼트이므로 확인응답을 보내지만, 세그먼트는 버릴 것이다.

두 번재 시나리오는 두 세그먼트를 연달아서 보낼 때이다. 처음 보낸 세그먼트가 타임아웃이 일어났으므로 다시 세그먼트를 보내지만, 연달아 보낸 두 세그먼트가 손실된 것이 아니라 단순히 **늦은 것이기 때문에** 타임아웃 이후에 도착하게 되고, 두 번째 세그먼트도 타임아웃 이전에 돌아왔으므로 재전송하지 않을 것이다.

세 번째 시나리오는 두 개의 세그먼트를 연달아 보냈는데 처음 세그먼트의 확인 세그먼트가 손실된 경우이다. 이때 첫 번쨰 세그먼트의 타임아웃 전에 두 번째 세그먼트의 확인응답을 수신하면, **누적 확인응답**이기 때문에 아무것도 재전송하지 않는다.


#### 타임아웃 주기의 두 배로 설정
타이머의 종료 이후에 타임아웃 주기 설정에 대해 알아보자. 타임 아웃이 발생할 때, TCP는 EstimatedRTT와 DevRTT에서 값을 가져오는 것이 아니라 이전 타임아웃 주기의 두 배로 타임아웃 주기를 설정한다. (만약, 계속 타임아웃될 경우 계속 2배로 늘어난다) 그리고, 타임아웃 전에 확인 응답을 받을 경우 다시 EstimatedRTT와 DevRTT를 사용하여 타임아웃 주기를 설정한다. 

이런 설정은 **제한된 형태의 혼잡 제어를 제공**한다. 타임아웃이 발생했다는 것은 네트워크가 혼잡하다는 것인데 이때 계속해서 재전송을 고집한다면 오히려 네트워크가 더 혼잡해진다. **따라서, TCP는 송신자가 더 긴 간격으로 재전송하도록 하는 것이다.**

#### 빠른 재전송
타임아웃의 문제점 중 하나는 타임아웃의 주기가 때때로 비교적 길다는 것이다. 타임아웃이 길면, 패킷을 다시 보내기 전에 오랫동안 송신자를 기다리게 해서 **종단 간의 지연**이 발생한다. 따라서, **중복 ACK를 사용해서 타임아웃이 발생하기 전에 패킷 손실을 발견해야한다.**

**중복 ACK** : 송신자가 이미 받은 ACK에 대한 재확인 응답 세그먼트 ACK이다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/5ec9ba3c-d3ae-41c0-888f-301b8b526d62/image.png)
TCP 생성권고를 보면 알 수 있듯이, 다음 것에 비해높은 순서번호를 가진 세그먼트를 받게 되면, **TCP 수신자는 데이터 스트림에서의 손실 세그먼트를 찾아서 중복 ACK를 보낸다. ** 이런 중복 ACK가 3개 보내지면 TCP는 타이머가 만료되기 이전에 손실 세그먼트를 재전송하는 **빠른 재전송**을 한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/dd19338b-b47f-4a10-bd10-a8d261b103ad/image.png)

#### GBN인가 SR인가?
TCP가 GBN 프로토콜일까, 아니면 SR 프로토콜일까?
결론적으로 TCP 송신자는 확인응답안된 가장 작은 순서 번호(sendBase)와 다음에 보낼 순서 번호(NextSeqNum)을 알아야 한다. 이런 관점에서 TCP 송신자는 **GBN과 유사**해 보인다. 그러나 **TCP는 순서가 바뀐 세그먼트들을 버퍼링하여 저장한다.** 즉, n에 대해서 손실이 일어났을 때 GBN은 n+1, n+2 등등을 재전송하지만, TCP는 n 하나만을 재전송한다. 또한, 타임 아웃 전에 n + 1에 대한 긍정확인응답이 도착했다면, 세그먼트를 재전송하지 않는다.
 TCP에서 제안된 것은 **선택적 확인응답**이라고 하는 것으로, 순서가 틀린 세그먼트에 대해 선택적으로 확인응답을 하게 한다. (SR과 매우 유사)
 
> **따라서 TCP는 GBN과 SR의 혼합으로 분류**한다.

### 3. 흐름 제어
tcp는 데이터를 수신 버퍼에 저장한다. 수신하는 애플리케이션은 다른 작업으로 바쁘기 때문에 수신 버퍼에 저장하게 된다. 이떄, **흐름제어**가 없다면 연결된 수신 버퍼에 점점 더 많은 데이터가 쌓이면서 쉽게 오버플로가 발생된다.
 이렇게 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 송신자와 수신자의 속도를 맞추는 **흐름 제어 서비스**를 제공한다. 앞에서 네트워크의 혼잡으로 인해 억제되는 **혼잡 제어**와는 비슷하지만 목적이 다르다. 
 흐름 제어 서비스는 **송신자가 수신 윈도라는 변수를 유지하면서 제공한다.**이 수신 윈도 변수는 수신 측에서 송신자에게 가용 버퍼공간을 알려주는데 사용된다. 이떄 할당되는 버퍼를 RcvBuffer라고 해보자. 수신자 호스트는 버퍼로부터 데이터를 읽으면서 다음과 같은 변수들을 정의한다.
 - LastByteRead : 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 번호
 - LastByteRcvd : 호스트 B에서 네트워크로부터 도착하여 수신 버퍼에 저장된 마지막 데이터 스트림 번호
 - LastByteRcvd - LastByteRead <= RcvBuffer
 - rwnd = RcvBuffer - [LastByteRcvd - LastByteRead] 
 
 ![](https://velog.velcdn.com/images/choiyoung6609/post/825154eb-dc5d-45b2-bd30-3deccf16247c/image.png)

수신 윈도 rwnd를 어떻게 사용할까?
먼저 호스트 B는 윈도 필드에 현재 rwnd 값을 설정해서 세그먼트를 보냄으로써 현재 버퍼에 얼만큼 여유 공간이 있는지 호스트 A에게 알려준다. 

한편 호스트 A에서는 LastByteSent 변수와 LastByteAcked 변수를 가진다. 이 두 변수의 차이는 보냈지만 전송 확인 응답이 오지 않은 변수들을 의미하며 이 차이값을 항상 **rwnd보다 작게 유지**한다. 

**LastByteSent - LastByteAcked <= rwnd**

그러나 이 방식에는 **문제가 있다.** rwnd가 0이라고 알린 후 호스트 B가 호스트 A에게 전송할 게 없다고 가정하자. 만약 **호스트 B에서 버퍼가 비워지더라도 tcp는 새로운 rwnd로 새로운 세그먼트를 전송하지 않는다.** 즉, **호스트 A는 호스트 B의 버퍼가 비워졌느지 모르고 데이터를 전송하지 않는다.**
 이 문제를 해결하기 위해서 호스트 A가 호스틑 B의 수신 윈도가 0이라면 1바이트 데이터로 세그먼트를 계속해서 전송한다. 결과적으로 버퍼는 비워지고 긍정 확인 응답은 0이 아닌 현재 rwnd 값을 넣어 전송하게 될 것이다. 
 
UDP는 TCP와 다르게 흐름제어를 제공하지 않기 떄문에 버퍼가 오버플로되고, 세그먼트가 손실되는 현상이 발생한다.

### 6. TCP 연결관리
tcp 연결이 중요한 이유는 TCP 연결에서 발생하는 지연과 SYN Flood 공격과 같은 TCP 연결 관리의 취약점 때문이다. 이번 장에서는 어떻게 TCP가 연결되는지 살펴본다. 

처음에 클라이언트 프로세스가 서버 프로세스와 연결되고자 할 경우 클라이언트 프로세스는 TCP 클라이언트에게 연결하고자함을 알린다. 그렇게 되면 TCP 클라이언트는 다음과 같은 TCP 설정을 시작한다.

![](https://velog.velcdn.com/images/choiyoung6609/post/4fa4ba32-9d4f-4047-9ec5-939212a323d8/image.png)


- 1단계 : TCP 클라이언트는 서버 클라이언트에게 애플리케이션 계층 데이터를 포함하지 않는 특별한 세그먼트를 전송한다. 이 비트는 TCP 연결을 시작한다는 의미로 SYN 비트(플래그 비트)를 1로 설정하고 자신의 최초 순서 번호를 임의로 선택하여 TCP SYN 세그먼트의 순서 번호 필드에 넣는다. 이떄, _특정 보안 공격을 피하기 위해 client_isn(순서 번호)는 임의로 설정된다._
- 2단계 : TCP SYN 세그먼트가 서버에 도착하면 서버는 TCP 버퍼와 변수를 할당하고, 클라이언트에 **연결 승인 세그먼트를 송신**한다. 이때, 애플리케이션 데이터를 포함하지 않으며 SYN 비트가 1로 설정된다. 또한, 확인 응답 필드가 client_isn+1로 설정되고, 자신의 최초의 순서번호(server_isn)가 임의로 선택되어 순서 번호 필드에 넣어진다. => **SYNACK Segment**
-3단계 : 연결 승인 세그먼트를 수신하면, 클라이언트는 버퍼와 변수를 할당하고, 서버에게 연결 승인 세그먼트를 확인하는 세그먼트를 보낸다.(확인응답 필드에 server_isn+1값을 넣음) 연결이 설정되었기 때문에 SYN 비트는 0으로 설정되고, 클라이언트에서 서버로의 데이터를 세그먼트 페이로드에서 운반할 수 있다.

일단 세 단계가 완료되면 서로에게 데이터(세그먼트)를 보낼 수 있다. 그리고 이러한 데이터는 연결이 된 이후이기 때문에 SYN 비트가 0이 된다. 

제대로 된 연결에는 모두 제대로 된 끝이 있어야 한다. TCP 연결 또한 제대로 된 끝맺음이 있어야 하는데 tcp 연결 중인 두 프로세스 중 하나가 연결을 끝낼 수 있다.(모든 자원이 회수됨) 

![](https://velog.velcdn.com/images/choiyoung6609/post/7035f98a-95b7-4339-8822-aead318ba5d0/image.png)

그림은 클라이언트가 연결 종료를 결정하는 그림이다. TCP 클라이언트에서 종료를 결정하고 서버에게 특별한 세그먼트를 보낸다. 이때 FIn 비트를 1로 설정한다. 서버가 이 비트를 수신하면 확인응답을 보낸다. 그 다음에 FIN 비트가 1로 설정된 종료 세그먼트를 서버가 클라이언트에게 보내면 클라이언트는 여기에 확인 응답을 한다. **이떄 모든 자원은 회수된다.**

이렇게 TCP가 연결되고, 데이터를 주고받고, 끊어질동안 여러 ** TCP 상태**를 전이한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/1b498f84-df0f-4b77-a16b-c45c497481a1/image.png)
위는 클라이언트의  전이 상태를 표현한 그림이다. 클라이언트는 연결 전에 CLOSED 상태에서 시작한다. 새로운 TCP 연결을 시작할 때(소켓 객체를 생성), 서버에게 SYN을 전송하면서 **SYN_SENT**상태가 된다. 그 다음에 SYN과 ACK를 수신하고 다시 ACK를 보내면 데이터를 주고받을 수 있는 **ESTABLISHED**상태로 된다. 그러다가 연결을 종료하고 싶어지면 FIN비트가 1인 세그먼트를 전송하고 **FIN_WAIT_1** 상태가 된다. FIN_WAIT_1동안 ACK를 수신하게 되면 추가 전송 없이 **FIN_WAIT_2**상태로 들어가고, 서버로부터 FIN 비트를 포함한 다른 세그먼트를 기다린다. 이후, 세그먼트를 수신하면 ACK를 송신하고 **TIME_WAIT** 상태로 바뀐다. 이 상태에서는 마지막 ACK가 손실된 경우 재전송하도록 한다. <구현에 의해 TIME_WAIT시간 바뀜>

![](https://velog.velcdn.com/images/choiyoung6609/post/320661ca-dd15-4ebb-b2f0-a4a60fd14198/image.png)

위는 서버의 상태 전이인데 클라이언트와 서버가 통신할 준비가 되어 있을 경우 **서버에서는 클라이언트가 SYN 세그먼트를 보낸 것을 포트로 듣고 있어야 한다.(LISTEN상태)** 이떄 만약 소켓과 상관없는 세그먼트를 수신받을 경우 RST 플래그 비트를 1로 설정한 세그먼트를 클라이언트에게 전송한다.


목표 호스트의 특정 포트에 TCP SYN 세그먼트를 보낼 때 세 가지 결과가 있다.
- **출발지 호스트가 목표 호스트로부터 TCP SYNACK 세그먼트를 수신한다.** => 포트가 열려있다.
- **출발지 호스트가 목표 호스트로부터 TCP RST 세그먼트를 받는다.** => 포트가 닫혀있다. 그러나 방화벽에 의해 세그먼트가 차단되지 않기 떄문에 공격할 수 있다.
- **출발지가 아무것도 받지 않는다.** SYN 세그먼트가 중간에 있는 방화벽에 차단되어 호스트에 도달하지 못했음을 의마한다. 

