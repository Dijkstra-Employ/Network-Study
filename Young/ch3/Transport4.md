## 신뢰적인 데이터 전송의 원리
신뢰적인 데이터 전송의 문제는 **트랜스포트 계층 뿐만 아니라 링크 계층과 애플리케이션 계층에서도 발생**할 수 있는 문제이다.
![](https://velog.velcdn.com/images/choiyoung6609/post/147ad873-cc7c-478c-aeb3-8200ec13f669/image.png)

🤗 그렇다면 **신뢰적인 서비스 제공**이란 무엇일까???
- 전송된 데이터가 손상되지 않고, 손실되지 않는 것. 그리고 모든 데이터가 순서대로 제공되는 것을 의미한다.
=> TCP는 이러한 신뢰적인 서비스를 애플리케이션 계층에 제공해준다.

따라서 애플리케이션 계층에서는 TCP를 이용할 시 **신뢰적인 데이터라고 생각하여 있는 그대로 받아들이면 되는 것이다.** 이러한 추상화를 제공하는 것이 **신뢰적인 데이터 전송 프로토콜의 의무**이다. 
그러나, 이러한 신뢰적인 서비스가 어려운 이유는 **아래 계층에서 비신뢰적인 상황**이 있을 수 있기 때문이다. 

이번 장에서는 **단방향 데이터 전송**인 경우만 살펴볼 것으로, 송신측에서 수신 측까지의 데이터 전송만을 고려한다. 


### 1. 신뢰적인 데이터 전송 프로토콜의 구축

> **완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송 : rdt1.0**

하위 채널에서의 전송이 완벽하게 reliable한 경우 상위 계층에서 할 일은 딱히 없다. 
이 경우 **FSM(유한 머신 상태)**를 확인했을 때, 하나의 상태밖에 가지지 못한다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/23530789-d961-4c93-826b-c0ae25e2320f/image.png)

이 경우, no packet errors와 no packet loss이기 때문에 수신 측이 송신 측에게 어떠한 피드백도 제공하지 않아도 된다.

> **비트 오류가 있는 채널 상에서의 신뢰적인 데이터 전송: rdt2.0**

실제 하위 채널에서는 보통 **손상**이 발생하기도 한다.
이럴 때 송신 측에서는 보통 잘 받았다는 **긍정 확인 응답**과 손상됐다는 **부정 확인응답**을 통해서 피드백을 송신자에게 전달한다. 이렇게 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 **자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜**이라고 한다.

```
🍒 이런 프로토콜에게 필요한 기능은 무엇이 있을까?
```
1. 오류 검출 : 오류가 생겼는지 확인하는 작업이 필요하다. ex) UDP의 체크섬 필드
=> 이를 위해서 체크섬 bits를 추가하면 된다(패킷의 패킷 체크섬 필드)

2. 수신자 피드백 : 오류가 난 패킷을 받았는지 수신자는 송신자에게 피드백을 통해 알려줘야 한다.(ex) 긍정 확인응답, 부정확인 응답 - 1bit)

3. 재전송 : 오류가 발생했으면 재전송하는 기능이 필요하다.

![](https://velog.velcdn.com/images/choiyoung6609/post/96b67788-df5b-4a30-9610-a2bbc34fb08c/image.png)

rdt2.0의 FSM은 사진과 같다.

송신 측은 2개의 상태를 갖는데, 상위 호출을 기다리는 상태와 피드백을 기다리는 상태로 나뉜다. 상위로부터 호출될 때 데이터와 함께 **checksum bit**를 포함하는 패킷을 만드는 것을 유의해야 한다. 그리고 패킷이 전송되면 wait for ACK or NAK 상태로 바뀐다. 이때, 제대로 ACK가 들어오면 다시 wait for call from above상태로 바뀌고, NAK이 들어오면 재전송하는 기능이 포함된다.

그리고 이렇게 정확하게 수신됐음을 확인하기 전까지 새로운 데이터를 전달하지 않는 프로토콜을 **전송 후 대기 프로토콜**이라고 한다. rdt 2.0

송신 측에서는 여전히 단일 상태를 가지는데 오류가 발생하지 않았다면 ACK이라고 응답하고 데이터를 상위로 올리고, 다시 기다린다. 만약 오류가 발생했다면 NAK을 보내고 다시 응답을 기다린다. 

--- 

**그러나, rdt2.0에는 치명적인 결함이 존재한다**
바로, **피드백에서 오류가 발생하는 경우를 고려하지 않은 것**이다. 

따라서, ACK와 NAK에도 checksum 비트를 추가해야 하며(오류 검출), **오류 복구 기능** 또한 필요하다는 것이다. 다음은 이를 처리하기 위한 세 가지 방법이다.

1) **오류가 발생했을 때, 재전송을 요청하는 비트를 보내는 방법** => 이 재전송을 요청할 때도 오류 발생할 수 있음 => 무한반복
2) 송신자가 검출 뿐만 아니라 비트 오류로부터 회복할 수 있도록 **충분한 체크섬 비트들을 추가하는 방식** => _손상될 수 있으나 손실되지는 않는 채널의 경우 즉각적인 문제해결 가능_
3) 오류 발생 시 **현재 데이터 패킷을 다시 송신하는 방법**. 이 방법은 **중복 패킷이 발생할 수 있다** 그러나 이는 마지막으로 전송된 ACK 또는 NAK가 송신자에게 정확하게 전달됐는지 알 수 없다는게 문제다. 즉, 새로 도착하는 패킷이 새로운 데이터인지 중복 데이터인지 수신자는 알 수가 없다.
=> **순서 번호 삽입**을 통해 해결

순서 번호를 가지게 되면 새로 전송된 것인지 재전송된 비트인지 확인할 수 있다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/985a3ae1-40ab-4cd1-8dbe-a18091f2cabf/image.png)

![](https://velog.velcdn.com/images/choiyoung6609/post/eb136973-fa3a-47d0-9911-13b970e438f3/image.png)

프로토콜 2.1은 긍정 확인응답과 부정 확인응답을 모두 포함하여 대답하는 것이다.
그러나, ACK만으로도 제대로 수신하였는지 확인할 수 있는데 NAK 대신에 가장 최근에 정확하게 수신된 패킷에 대한 ACK를 송신하게 되면 순서번호가 예전 것 + ACK가 되기떄문에 송신자 입장에서는 NAK를 전달받은 것과 같다. 

즉, NAK 대신에 순서번호를 도입한 ACK를 사용하는 것이다 
![](https://velog.velcdn.com/images/choiyoung6609/post/0e7da96b-5ac8-44a0-b19e-8605908a90c6/image.png)
![](https://velog.velcdn.com/images/choiyoung6609/post/bc7acd3f-0d9f-4704-9721-20b5e97aa5aa/image.png)


> **비트 오류와 손실 있는 채널 상에서의 신뢰적ㅇ니 데이터 전송 : rdt 3.0**

비트 오류 뿐만이 아니라 중요한 것은 전달 과정에서 **손실이 있는 경우**이다. 
먼저 손실을 검출하는 방법은 무엇일까?
정답은 바로 **Timer를 사용**하는 것이다.

Timer 시간이 짧다면 유실 시 reaction이 빠르지만, 중복이 발생할 가능성이 커진다.
반면에 Timer 시간이 길다면 중복 발생 가능성이 적지만, loss 시 반응이 늦어진다.
따라서, **적당한 양의 time을 설정**해야 한다.

그런데 만약 ACK가 **단순히 지연된 것이지, loss된 상황이 아니라면 어떻게 될까?** 중복 packet의 경우, 이전처럼 순서번호를 통해서 해결할 수 있다.
