## 신뢰적인 데이터 전송의 원리
신뢰적인 데이터 전송의 문제는 **트랜스포트 계층 뿐만 아니라 링크 계층과 애플리케이션 계층에서도 발생**할 수 있는 문제이다.
![](https://velog.velcdn.com/images/choiyoung6609/post/147ad873-cc7c-478c-aeb3-8200ec13f669/image.png)

🤗 그렇다면 **신뢰적인 서비스 제공**이란 무엇일까???
- 전송된 데이터가 손상되지 않고, 손실되지 않는 것. 그리고 모든 데이터가 순서대로 제공되는 것을 의미한다.
=> TCP는 이러한 신뢰적인 서비스를 애플리케이션 계층에 제공해준다.

따라서 애플리케이션 계층에서는 TCP를 이용할 시 **신뢰적인 데이터라고 생각하여 있는 그대로 받아들이면 되는 것이다.** 이러한 추상화를 제공하는 것이 **신뢰적인 데이터 전송 프로토콜의 의무**이다. 
그러나, 이러한 신뢰적인 서비스가 어려운 이유는 **아래 계층에서 비신뢰적인 상황**이 있을 수 있기 때문이다. 

이번 장에서는 **단방향 데이터 전송**인 경우만 살펴볼 것으로, 송신측에서 수신 측까지의 데이터 전송만을 고려한다. 


### 1. 신뢰적인 데이터 전송 프로토콜의 구축

> **완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송 : rdt1.0**

하위 채널에서의 전송이 완벽하게 reliable한 경우 상위 계층에서 할 일은 딱히 없다. 
이 경우 **FSM(유한 머신 상태)**를 확인했을 때, 하나의 상태밖에 가지지 못한다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/23530789-d961-4c93-826b-c0ae25e2320f/image.png)

이 경우, no packet errors와 no packet loss이기 때문에 수신 측이 송신 측에게 어떠한 피드백도 제공하지 않아도 된다.

> **비트 오류가 있는 채널 상에서의 신뢰적인 데이터 전송: rdt2.0**

실제 하위 채널에서는 보통 **손상**이 발생하기도 한다.
이럴 때 송신 측에서는 보통 잘 받았다는 **긍정 확인 응답**과 손상됐다는 **부정 확인응답**을 통해서 피드백을 송신자에게 전달한다. 이렇게 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 **자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜**이라고 한다.

```
🍒 이런 프로토콜에게 필요한 기능은 무엇이 있을까?
```
1. 오류 검출 : 오류가 생겼는지 확인하는 작업이 필요하다. ex) UDP의 체크섬 필드
=> 이를 위해서 체크섬 bits를 추가하면 된다(패킷의 패킷 체크섬 필드)

2. 수신자 피드백 : 오류가 난 패킷을 받았는지 수신자는 송신자에게 피드백을 통해 알려줘야 한다.(ex) 긍정 확인응답, 부정확인 응답 - 1bit)

3. 재전송 : 오류가 발생했으면 재전송하는 기능이 필요하다.

![](https://velog.velcdn.com/images/choiyoung6609/post/96b67788-df5b-4a30-9610-a2bbc34fb08c/image.png)

rdt2.0의 FSM은 사진과 같다.

송신 측은 2개의 상태를 갖는데, 상위 호출을 기다리는 상태와 피드백을 기다리는 상태로 나뉜다. 상위로부터 호출될 때 데이터와 함께 **checksum bit**를 포함하는 패킷을 만드는 것을 유의해야 한다. 그리고 패킷이 전송되면 wait for ACK or NAK 상태로 바뀐다. 이때, 제대로 ACK가 들어오면 다시 wait for call from above상태로 바뀌고, NAK이 들어오면 재전송하는 기능이 포함된다.

그리고 이렇게 정확하게 수신됐음을 확인하기 전까지 새로운 데이터를 전달하지 않는 프로토콜을 **전송 후 대기 프로토콜**이라고 한다. rdt 2.0

송신 측에서는 여전히 단일 상태를 가지는데 오류가 발생하지 않았다면 ACK이라고 응답하고 데이터를 상위로 올리고, 다시 기다린다. 만약 오류가 발생했다면 NAK을 보내고 다시 응답을 기다린다. 

--- 

**그러나, rdt2.0에는 치명적인 결함이 존재한다**
바로, **피드백에서 오류가 발생하는 경우를 고려하지 않은 것**이다. 

따라서, ACK와 NAK에도 checksum 비트를 추가해야 하며(오류 검출), **오류 복구 기능** 또한 필요하다는 것이다. 다음은 이를 처리하기 위한 세 가지 방법이다.

1) **오류가 발생했을 때, 재전송을 요청하는 비트를 보내는 방법** => 이 재전송을 요청할 때도 오류 발생할 수 있음 => 무한반복
2) 송신자가 검출 뿐만 아니라 비트 오류로부터 회복할 수 있도록 **충분한 체크섬 비트들을 추가하는 방식** => _손상될 수 있으나 손실되지는 않는 채널의 경우 즉각적인 문제해결 가능_
3) 오류 발생 시 **현재 데이터 패킷을 다시 송신하는 방법**. 이 방법은 **중복 패킷이 발생할 수 있다** 그러나 이는 마지막으로 전송된 ACK 또는 NAK가 송신자에게 정확하게 전달됐는지 알 수 없다는게 문제다. 즉, 새로 도착하는 패킷이 새로운 데이터인지 중복 데이터인지 수신자는 알 수가 없다.
=> **순서 번호 삽입**을 통해 해결

순서 번호를 가지게 되면 새로 전송된 것인지 재전송된 비트인지 확인할 수 있다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/985a3ae1-40ab-4cd1-8dbe-a18091f2cabf/image.png)

![](https://velog.velcdn.com/images/choiyoung6609/post/eb136973-fa3a-47d0-9911-13b970e438f3/image.png)

프로토콜 2.1은 긍정 확인응답과 부정 확인응답을 모두 포함하여 대답하는 것이다.
그러나, ACK만으로도 제대로 수신하였는지 확인할 수 있는데 NAK 대신에 가장 최근에 정확하게 수신된 패킷에 대한 ACK를 송신하게 되면 순서번호가 예전 것 + ACK가 되기떄문에 송신자 입장에서는 NAK를 전달받은 것과 같다. 

즉, NAK 대신에 순서번호를 도입한 ACK를 사용하는 것이다 
![](https://velog.velcdn.com/images/choiyoung6609/post/0e7da96b-5ac8-44a0-b19e-8605908a90c6/image.png)
![](https://velog.velcdn.com/images/choiyoung6609/post/bc7acd3f-0d9f-4704-9721-20b5e97aa5aa/image.png)


> **비트 오류와 손실 있는 채널 상에서의 신뢰적ㅇ니 데이터 전송 : rdt 3.0**

비트 오류 뿐만이 아니라 중요한 것은 전달 과정에서 **손실이 있는 경우**이다. 
먼저 손실을 검출하는 방법은 무엇일까?
정답은 바로 **Timer를 사용**하는 것이다.

Timer 시간이 짧다면 유실 시 reaction이 빠르지만, 중복이 발생할 가능성이 커진다.
반면에 Timer 시간이 길다면 중복 발생 가능성이 적지만, loss 시 반응이 늦어진다.
따라서, **적당한 양의 time을 설정**해야 한다.

그런데 만약 ACK가 **단순히 지연된 것이지, loss된 상황이 아니라면 어떻게 될까?** 중복 packet의 경우, 이전처럼 순서번호를 통해서 해결할 수 있다.


### 2. 파이프라이닝된 신뢰적인 데이터 전송 프로토콜 
rdt3.0은 기능적으로 좋은 프로토콜이지만, **전송 후 대기 프로토콜**이기 떄문에 시간이 오래 걸린다.

예를 들어, 두 종단 시스템에서 **광속 왕복 전파 지연(RTT)가 30ms**이고, 1_Gbps 전송률(R)을 가진 채널_로 연결되어 있다고 가정하자. 패킷 당 1000바이트(8000비트)를 가지고 있을 떄, 실제로 전송하는 시간은 d = 8000/10^9 = 8us이다. 즉, 15.008 ms에 수신 측으로 패킷이 전송된다. ACK 패킷은 충분히 빠르고 작다고 가정했을 떄 송신자 패킷은** ACK 패킷을 30.008ms 후**에 받을 수 있다. 이떄 송신자 이용률은 0.008/30.008 이기 때문에 0.00027을 갖는다. 즉, **송신자는 단지 시간의 0.027%만큼만 바쁜 것이다.** 여기에 라우터 등에서 발생하는 지연 시간을 포함하면 더욱 안좋은 성능을 가지게 된다.

**이때 고안할 수 있는 방법은, 확인응답을 기다리지 않고 여러 패킷을 한 번에 보내는 방식이다. ** 이 기술을 **파이프라이닝**이라고 한다. 
이 방식은 다음과 같은 중요성을 가지고 있다.

- **순서 번호의 범위가 커져야 한다.** 그 이유는 각각의 패킷을 구분하여야 하기 때문이다.(전송 중에 확인 응답이 안된 패킷이 여럿 있을 지도 모르기 떄문)
- 프로토콜의 송신 측과 수신 측은 적어도 하나 이상을 버퍼링해야 한다. 즉, **최소한 전송되었으나 확인응답되지 않은 패킷을 버퍼링해야 한다.**
- 필요한 순서 번호의 범위와 버퍼링 조건은 오류 회복 방법에 따라 달려 있다. 대표적으로 파이프라인에서 오류 회복 방식은 **GBN(Go-Back-N)과 SR(Selective Repeat)**이 있다.

### 3. GBN
**GBN 프로토콜**은 확인패킷을 기다리지 않고 여러 패킷을 전송할 때 가능하다. 그러나, 패킷을 전송할 때 확인응답이 안된 패킷이 최대 허용 수 N보다는 크지 말아야 한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/d3d66291-adf3-4e1e-8456-b4f2b39cd9aa/image.png)


N 윈도 : 확인응답이 안 된 패킷을 위해 허용할 수 있는 순서 번호의 범위
이 윈도는 순서 번호 공간에서 오른쪽으로 이동한다. 이러한 이유로 **N을 윈도 크기라고 부르며, GBN 프로토콜은 슬라이딩 윈도 프로토콜**이라고 부른다. 

> 왜 확인 응답이 안 된 패킷의 수를 N으로 제한할까? 왜 패킷들이 무한한 번호를 가지지 않을까 ? 
-> 이후에 흐름제어와 혼잡제어를 다룰 때 설명할 것이다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/176e8dd6-a133-4a11-9152-0ecad2a18a23/image.png)

실제로 패킷의 순서 번호는 헤더에 포함되는데 kbit를 가질 때 [0, 2^k - 1] 길이를 갖는다. TCP에서 순서 번호 필드는 32bit인데 이 비트는 패킷 단위가 아니라 바이트 스트림 단위이다. 

GBN 송신자는 다음과 같은 3가지 이벤트에 반응해야 한다.
- 상위로부터 호출 : 상위로부터 호출되면, 윈도가 가득 찼는지(확인 응답되지 않은 패킷이 N개 인지) 확인한다. 만약 가득 차 있지 않다면 패킷이 생성되고 송신된다. 그리고 변수들(base 등)이 적절하게 갱신된다. 만약 가득 차 있지 않다면 데이터를 사우이 계층으로 반환한다. 
- ACK의 수신 : GBN 프로토콜에서 순서번호 k를 가진 패킷에 대해 확인응답이 왔다면 이 확인응답은 **누적확인응답**이다. 즉, n까지의 순서 번호를 가진 모든 패킷에 대한 확인 응답이다.
- 타임아웃이벤트 : 타임아웃 이벤트가 발생한다면 아직 응답받지 못한 모든 전송되었던 패킷을 재전송한다. GBN은 가장 처음의 '전송했지만 아직 확인응답 안 된 패킷'에 대한 타이머라고 생각되는 단일 타이머를 사용한다. 만약 ACK가 수신되었을 떄, 이런 패킷이 존재한다면 타이머는 다시 시작하고 아니라면 타이머는 다시 멈춘다.

![](https://velog.velcdn.com/images/choiyoung6609/post/cd6281e6-4262-43a0-aaa3-51932a8e8262/image.png)

GBN의 수신자의 경우 먼저 순서 번호 n을 가진 패킷이 제대로 수신된다면 수신자는 n  패킷에 대한 ACK를 송신하고, 상위 계층에 데이터를 전달한다. 
그 외의 경우에는 수신자는 패킷을 버리고 최근에 전송된 ACK를 다시 재전송한다. 

GBN 프로토콜에서 수신자는 순서가 잘못된 패킷을 그냥 버린다. 수신자가 n보다 n+1을 먼저 받아서 n+1을 버퍼링에 저장하더라도 GBN 재전송 법칙에 따라 손실 발생 시 n과 n+1이 송신자에 의해서 다시 모두 재전송된다. 이러한 경우 **버퍼링이 간단하다는 장점**이 있다. 즉, **수신자가 순서가 잘못된 패킷에 대해서 버퍼링을 할 필요가 없다는 것**이다. 따라서 송신자는 nextseqnum 위치를 유지해야 하지만, 수신자는 단지 다음 순서 패킷의 순서 번호를 알면 된다. 그리고 이 값은 **expectedseqnum에서 유지**된다. 

물론 올바르게 수신된 패킷을 버리는 것의 단점은 재전송된 패킷이 손실되거나 왜곡될 때 많은 재전송이 필요하다는 점이다.

### SR
GBN 프로토콜은 파이프라인을 가능하게 하여, 채널 이용률 문제를 피하도록 하고 있다. 그러나 GBN 자체의 문제도 있는데 윈도 크기와 대역폭 지연 곱의 결과가 모두 클 떄, 패킷 **하나의 오류 때문에 많은 패킷을 재전송할 경우**가 발생한다는 것이다.

SR은 이름처럼 **오류가 발생한 패킷을 선택하여 송신자가 다시 전송하는 것으로 불필요한 재전송을 피한다.** 이떄 필요에 따라 개별적인 확인응답이 요구된다. 윈도 크기 N은 파이프라인에서 아직 확인응답이 안 된 패킷 수를 제한하는데 사용된다. 그러나 여기서는 몇몇 패킷에 대한 ACK를 이미 수신했을 것이다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/1d859077-0020-468b-805a-b7eaf620062e/image.png)

SR 수신자는 패킷 순서와 상관없이 수신된 패킷에 대한 확인응답을 한 것이다. 순서가 빠진 패킷을 기다리다가 버퍼에 저장하고, 나중에 다시 전달받으면 일련의 패킷 모음을 상위 계층으로 전달한다. 

1. 상위로부터 데이터 수신 : 상위에서 데이터가 수신될 떄, 순서 번호를 검사하여 순서 번호가 윈도 내에 있으면 데이터는 패킷으로 송신된다. 그렇지 않으면 다시 상위로 되돌려진다.
2. 타임아웃 : 손실된 패킷ㅇ르 보호하기 위해 재사용된다. 각 패킷은 자신만의 논리 타이머가 있어야 한다.(하나의 물리 테이머)
3. ACK 수신 : ACK가 윈도 내에 있다면 수신된 것으로 표시되고, 패킷 번호가 send_base라면 가장 작은 순서 번호를 가진 아직 확인되지 않는 패킷으로 옮겨진다.
=> SR  송신자 이벤트

1. rcv_base, rcv_base+N-1 내의 순서번호를 가진 패킷이 손상없이 수신될 떄 : 선택적인 ACK 패킷이 송신자에게 회신된다. 이전에 수신되지 않았던 것이라면 버퍼에 저장된다. 만약 순서번호가 rcv_base라면 연속적으로 번호를 가진 패킷들은 상위 계층으로 전달된다. 
2. rev_base - N, rcv_base - 1 내의 순서번호를 가진 패킷이 수시ㄴ도리 경우 ACK를 생성하여 보내준다.
3. 그 외의 경우 패킷을 무시한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/12d106c4-c23f-49bb-b762-a379ee77e9b7/image.png)

수신자의 2번 행동이 정말 중요한데 송신자 측은 ACK가 손실되어서 못받고, send_base에서 기다리고 있는데 수신자가 이미 받은 것이라고 재전송을 안해준다면 send_base 패킷을 계속 기다릴 것이기 떄문이다.(계속 송신자가 재전송하면서)

![](https://velog.velcdn.com/images/choiyoung6609/post/755b93a7-dc51-46b5-bcfb-d30fa78546f0/image.png)


SR 프로토콜의 중요한 점은 송신자와 수신자가 항상 같은 관점을 가지지는 않는다는 것이다. 순서 번호가 0,1,2,3을 가지고 윈도가 3인 경우를 생각해보자. 
만약 그림 a처럼 수신자에거슨ㄴ 0,1,2가 확인되었지만 송신자는 맨처음 0,1,2를 받지 못했다. 그래서 다시 재전송하는 경우 수신자는 다음 3,0,1을 받는 상황이 되어버린다. 

사실 이것처럼 정상적인 5번째 패킷과 첫번째 패킷은 구분하기가 어렵다. 그렇다면 최소 윈도 크기는 어느 정도일까? 이는 **순서 번호 공간 크기의 절반보다 작거나 같아야 함을 보여준다. **

마지막 남은 하나의 가정은 사실 송신자와 수신자의 채널이 네트워크일 떄 **패킷 순서 바뀜 현상**이 발생할 수도 있다는 것이다. 즉, 송수신자가 윈도에 x를 포함하고 있지 않더라도 여러 복사본이 생길 수 있다는 것이다. 따라서 **패킷 순서가 바뀌더라도 버퍼에 저장하여 임의로 내보낸다고 간주할 수 있어야 한다.**






