## 비연결형 트랜스포트 : UDP
군더더기 없는 트랜스포트 프로토콜 설계에 관심이 있다면 ? 
제일 먼저 생각할 수 있는 것은 ⭐**어떠한 일도 하지 않는 프로토콜**⭐이다.

그러나 최소한의 기본적인 동작은 수행해야 하는데 그것이 대표적으로 **다중화와 역다중화**이다. 즉, UDP는 가장 기본적인 **다중화와 역다중화**와 **간단한 오류 검사 기능**만을 포함한다.(IP 프로토콜에 추가)

실제로 UDP는 IP에서 전달받은 데이터를 프로토콜로 전달하거나, 애플리케이션 데이터를 IP로 전달하는 최소한의 기능만 수행하기 때문에 애플리케이션 계층과 트랜스포트 계층이 직접 통신하는 셈이다. 

또한, **UDP**는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에서 핸드셰이크를 사용하지 않는 **비연결형**이라는 점을 기억해야 한다.

> 대표적인 UDP 예시로 DNS가 있다. 이때 질의 호스트에서의 DNS 애플리케이션은 질의에 대한 응답을 기다리는데, 만약 응답이 없다면 **다른 네임 서버에 질의를 보내거나, 이를 야기한 애플리케이션에 응답 없음을 통보한다.**

---

👉 _그렇다면 TCP가 더 기능이 많으니, **항상 TCP를 사용하는 것이 좋은 걸까?** UDP 방식보다 **TCP 방식을 무조건적으로 선호하는 걸까**?_
![](https://velog.velcdn.com/images/choiyoung6609/post/93987fc9-7a47-469b-8328-2f7702968839/image.png)

**---> NONONONONO**

UDP 방식도 선호되는 방식이다. 이유는 다음과 같다
**1.** **무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어**  
	UDP는 애플리케이션에서 데이터를 전달받자마자 거의 바로(헤더만 붙이고) 네트워크 계층으로 세그먼트를 넘긴다. 그러나 **TCP는 혼잡 제어 메커니즘을 가지고 있다.** 즉, 송수신자 사이에 하나 이상의 링크가 많이 혼잡해지면 **송신자를 제한**한다. 또한, _신뢰적인 전달을 위해서_ 목적지가 확인응답할 때까지 **데이터의 세그먼트를 계속 재전송**할 것이다. 이러한 경우, 실시간 애플리케이션에 맞지 않기 때문에 UDP를 사용하고, 애플리케이션에서 다른 기능을 추가하여 활용할 수 있다.
    
**2. 연결 설정 없음** 
	TCP와 다르게 UDP는 핸드쉐이크가 없기 때문에 연결 전 **어떠한 지연도 없다.** HTTP에서 신뢰성 때문에 보통 TCP를 사용하는데 웹 문서 다운로드 지연의 심각한 원인이 된다. 따라서, 요즘은 QUIC라는 프로토콜을 사용하는데 기본적으로 UDP를 사용하고 애플리케이션 계층에서 안정성을 구현한다.
    
**3. 연결 상태가 없음**
	TCP는 종단 시스템에서 연결 상태를 유지한다. 이떄 필요한 정보는 수신 버퍼, 송신 버퍼, 혼잡 제어 파라미터 등이 있다. 그러나, **UDP는 연결 상태가 없기 때문에 이 파라미터의 어떤 것도 기록하지 않는다.** 따라서, 어떤 애플리케이션에서는 TCP보다 UDP에서 동작할 때 일반적으로 좀 더 많은 액티브 클라이언트를 수용할 수 있다.
    
**4. 작은 패킷 헤더 오버헤드**
	TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 가지지만, UDP는 단지 8바이트의 오버헤드를 갖는다.
    
---

![](https://velog.velcdn.com/images/choiyoung6609/post/208360af-de6b-4bb2-ac2d-992a8499b137/image.png)
사진을 보면 알수 있듯이, UDP를 사용하는 상위 프로토콜도 많은데 대표적으로 SNMP가 있다. **또한, DNS도 보통 연결 설정 지연을 피하기 위해 UDP에서 동작한다.**

실제 실시간 스트리밍 같은 **멀티미디어 애플리케이션**은 UDP를 많이 사용하는데 약간의 패킷손실은 영향이 없기 때문에 **신뢰적인 데이터 전송의 필요성이 떨어진다**. 또한, **TCP 혼잡 제어가 지연이 발생**할 수 있어 **나쁜 영향**을 미친다.

_이처럼 혼잡 제어를 싫어하는 경우 UDP를 사용하는 경우도 있는데_ **사실 혼잡 제어는 폭주 상태에 빠지는 것을 막기 위해 꼭 필요하다**. 높은 비트의 비디오 스트리밍을 사용하는 경우, 라우터에 많은 패킷 오버플로가 발생하여 패킷을 많이 손실하게 된다. 그리고, 이런 손실을 감소시키기 위해 TCP 송신자들은 혼잡 제어를 통해서 속도를 감소시킨다. **즉, 이러한 방식은 높은 손실률을 가져올 뿐더러 TCP 세션의 혼잡이 발생할 수 있다.** 따라서 지금은 모든 출발지에서 **적응 혼잡 제어를 수행하는 새로운 메커니즘을 제시했다**.

=> UDP는 혼잡 제어를 사용하지 않지만, **UDP를 사용하더라도 혼잡 제어는 할 수 있다**는 것이다.
=> 또한, **애플리케이션이 신뢰성을 제공**하면 **UDP를 쓰더라도 신뢰적인 데이터 전송**을 할 수 있다.
=> 대표적으로 _QUIC 프로토콜_

---
### UDP 세그먼트 구조
애플리케이션에서 넘긴 데이터는 모두 UDP 데이터그램의 데이터 필드에 들어간다. 그리고 헤더 필드가 필요한데 **UDP 헤더에는 2바이트로 구성된 4개의 필드만 필요**하다.

-출발지 포트 번호 : 다중화와 역다중화
- 목적지 포트 번호 : 다중화와 역다중화
- 길이 : UDP 세그먼트의 길이(바이트 단위)
- 체크섬 : 간단한 오류 체크

---
### UDP 체크섬
UDP 체크섬은 **오류검출을 위한 것이다.**
=> 연결 도중 변경사항이 있는지 검사하는 것

![](https://velog.velcdn.com/images/choiyoung6609/post/3e1023ed-58c0-4730-8017-bde7f8efe40f/image.png)</br>

송신자에서는 UDP 세그먼트에 있는 16비트 워드를 모두 합산하고 합산값의 1의 보수를 수행한다. 이때, 오버플로 발생 시 윤회적 자리올림을 진행한다.
=> 이 결과값이 체크섬에 삽입된다.

이렇게 되면 수신자에서 데이터그램을 받았을 때 모든 16비트 워드를 더한다(체크섬 포함) **이때, 어떠한 오류도 없다면 모든 비트가 1로 구성되어야 한다.**

> 🤔 **링크 게층 프로토콜이 오류 검사를 대부분 지원하는데 왜 트랜스포트 계층에서도 오류 검사를 지원해야 할까?**</br>
	👉 정답은 모든 링크에서 오**류 검사를 제공한다는 보장이 없기 때문**이다. 따라서 **UDP는 종단 기반으로 오류 검사를 제공**한다.
    => **종단과 종단 원칙(end-end principle)**
    => 하위 레벨에 있는 기능들은 상위 레벨과 비교했을 때 중복되거나 거의 가치가 없을 수 있다는 것
    **다만 UDp는 오류 검사만 제공할 뿐 오류 회복에는 거의 힘쓰지 않는다.**


