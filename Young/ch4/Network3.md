## 3. 인터넷 프로토콜(IP) : IPv4, 주소체계, IPv6 등

 이번 절에서는 **오늘 날의 인터넷과 IP에서 네트워크 계층의 핵심적인 측면에 초점을 맞출 것이다**.
 현재 사용 중인 IP는 두 가지 버전이 있다. IPv4와 IPv4를 대체하도록 제안된 IP 버전 6이다. 
 
 ### 3.1 IPv4 데이터그램 포맷
  인터넷 네트워크 계층 패킷을 **데이터 그램**이라고 부른다. IPv4 데이터 그램의 포맷에 대해 얘기하면서 IP를 공부해보자. 
  ![](https://velog.velcdn.com/images/choiyoung6609/post/df3e46b9-4fa7-41b3-a3b3-bb9466bc8316/image.png)

- **버전** : 4비트로 IP 프로토콜 버전을 명시한다.(4버전 or 6버전) 라우터는 버전 정보를 확인하여 데이터그램의 나머지 부분을 어떻게 해석할지 결정한다. 각 버전에 따라 데이터그램의 포맷이 다르다.
- **헤더 길이** : 옵션에 따라 헤더 길이가 가변적으로 변하기 때문에 IP 데이터그램에서 **실제 페이로드가 시작하는 곳을 결정**한다. 대부분 옵션을 비워두기 때문에 헤더길이는 _20비트_가 된다.
-**서비스 타입** : IPv4에 포함된 서비스 타입(type of service, TOS) 비트는 **각기 다른 유형의 IP 데이터그램을 구분**한다.(not version) 예를 들어 실시간 데이터그램과 비실시간 데이터그램을 구분한다. 
- **데이터그램의 길이** : 바이트로 계산된** IP 데이터그램의 길이**이다. 보통 1500바이트보다 큰 경우는 거의 없기 때문에 이더넷 프레임의 페이로드 필드에 IP 데이터그램이 장착될 수 있다.
- **식별자, 플래그, 단편화 오프셋** : 이 셋 필드는 **IP 단편화와 관련**이 있다. 큰 IP 데이터그램은 여러 작은 IP 데이터그램으로 분할된 다음 최종 목적지에서 트랜스포트 계층으로 전달되기 전에 다시 모이게 된다.(6버전에서는 단편화 허용 안함)
-**TTL** : 네트워크에서 데이터그램이 **무한히 순환하지 않도록** 한다.(**라우팅 루프**) 따라서 이 필드값ㅇ느 데이터그램을 처리할 때마다 **감소**하며, **TTL이 0이 되면 라우터가 데이터그램을 폐기**한다.
- **프로토콜** : 일반적으로 최종 목적지에 도착했을 때만 사용되며, **트랜스포트 계층의 특정 프로토콜을 명시**한다. 포트 번호와 유사하게 **네트워크 계층과 트랜스포트 계층을 묶는 접착제 역할**을 한다. 
-**헤더 체크섬** : 헤더 체크섬은 **수신한 IP 데이터그램의 비트 오류를 탐지**하는데 도움을 준다. 라우터는 수신한 각 IP 데이터그램마다 헤더 체크섬을 계산하고 오류 상태임을 감지 및 폐기 처리한다. **TTL 필드와 옵션 필드의 값은 매번 변경되므로 체크섬은 각 라우터에서 재계산되고 저장되어야 한다.** TCP/UDP와 IP는 각각 다른 프로토콜들과 합쳐질 수 있기 때문에 따로 체크섬을 수행한다.
- **출발지와 목표 IP 주소** : 출발지가 데이터그램을 생성할 때 자신의 IP 주소를 삽입하고, 목적지 IP 주소를 목적지 IP 주소 필드에 삽입한다.
- **옵션** : IP 헤더를 확장하며, **오버헤드를 처리하기 위해 거의 사용되지 않는다.** 옵션에 따라 _라우터에서 IP 데이터그램을 처리하는데 필요한 시간_이 달라진다.(IPv6에는 옵션 없음)
- **데이터(페이로드)** : 대부분 **트랜스포트 계층의 세그먼트를 포함하지만, ICMP 같은 유형의 데이터를 담기도 한다.**

### 3.3 IPv4 주소체계
 IP 주소체계를 살펴보기 전에 호스트와 라우터가 인터넷에 연결되는 방식에 관한 단어를 정의할 필요가 있다. **호스트는 일반적으로 네트워크와 연결되는 하나의 링크**를 갖는다. 호스트가 IP 데이터그램을 보낼 때 이 데이터링크를 보낸다. **호스트와 물리적 링크 사이의 경계를 _인터페이스_라고 부른다.** 
 라우터는 최소 2개 이상의 연결된 링크가 필요하다. 라우터와 링크 사이의 경계 또한 인터페이스라고 한다.(링크마다 인터페이스 가짐) IP는 **각 호스트와 라우터 인터페이스가 IP 주소를 갖도록** 요구한다. **따라서 기술 면에서 IP 주소는 인터페이스를 포함하는 호스트, 라우터보다는 인터페이스가 가지고 있다.**
 
 각 IP 주소는 32비트 길이(4바이트)이다. 따라서 대략 40억개의 주소를 사용할 수 있고, 각 바이트를 십진수로 변환하는 **십진 표기법을 사용**한다. 
 
 각 호스트와 라우터 인터페이스는 고유한 IP 주소를 갖는다. 그러나 이러한 주소는 마음대로 선택할 수 있는 게 아니다. **인터페이스의 IP 주소 일부는 "서브넷"이 결정한다.**
 
 ![](https://velog.velcdn.com/images/choiyoung6609/post/e8a929e4-30f9-4e10-84af-a454d51e21fb/image.png)

위의 그림은 IP 주소체계와 인터페이스의 예를 보여준다. 위의 그림에서 3개의 인터페이스를 갖는 하나의 라우터는 7개의 호스트를 연결한다. 왼쪽 3개의 호스트와 연결된 하나의 라우터 인터페이스는 223.1.1.x의 형식의 IP 주소를 갖는다.(동일한 24비트) 또한, 이 4개의 인터페이스가 라우터 없이 하나의 네트워크에 연결되어 있어 **이더넷 LAN으로 상호연결되고, 인터페이스는 이더넷 허브나 이더넷 스위치, 무선 AP로 상호연결**된다. 

 IP 용어로 세 호스트 인터페이스와 라우터 인터페이스로 연결된 네트워크를 **서브넷**이라고 한다. 위에서 /24를 **서브넷 마스크**라고 부르는데, 32비트 중 **왼쪽 24비트가 서브넷 주소**임을 알려주는 것이다. 
 
 ![](https://velog.velcdn.com/images/choiyoung6609/post/c9576c64-689f-4a65-b99e-0445b5be7209/image.png)

 서브넷 IP 정의는 **이더넷 세그먼트만을 의미하는 것이 아니라 ,라우터끼리 연결에도 서브넷이 정의될 수 있다.**
 > 서브넷을 결정하려면 먼저 각 인터페이스를 분리하고 고립된 네트워크를 만든다. 이 고립된 네트워크의 종단점은 인터페이스의 끝이 된다. **이렇게 고립된 네트워크 각각을 _서브넷_이라고 부른다.**
 다수의 네트워크 구간과 네트워크 장치 사이의 연결에서는 하나의 서브넷을 가지르질 수 있는데, 이 안에서도 **여러 서브넷**을 만들 수 있다. 원칙대로라면 서로 다른 서버넷은 다른 서브넷 주소를 가져야 하지만, **실제로 서브넷 주소는 종종 같은 부분이 많다** 
 
 인터넷 주소 할당 방식에는 **CIDR**이라는 것이 있다. CIDR은 **서브넷 주소체계 표시를 일반화**하고 있다. 32비트 IP 주소를 두 부분으로 나누고, 다시 a.b.c.d./x를 가지며, 여기서 x는 두 부분으로 나눈 것 중 첫 부분의 비트 수이다.
 a.b.c.d/x 형식의 주소에서 **최상위 비트**를 의미하는 x는 **IP 주소의 네트워크 부분**을 구성한다. 보통 **프리픽스 또는 네트워크 프리픽스**라고 부른다. 한 기관은 보통 **공통 프리픽스를 공유**한다. 이는 라우터에서 사용하는데 라우터가 데이터 그램을 전달할 때, 프리픽스 x만 보고 결정한다. 
 **주소의 나머지 32-x 비트는 기관 내부의 장비를 구분**한다. 이 비트들은 기관 내부에서 패킷을 전달하는데 사용된다. 이 하위 비트들은 **추가 서브넷 구조**를 가질 수 있다.(앞에 언급) 예를 들어 a.b.c.d/21로 기관의 네트워크 프리픽스를 나타내고 a.b.c.d//24로 기관 내부의 특정 서브넷을 나타낼 수도 있다.
 CIDR가 채택되기 전에는 IP 주소의 네트워크 부분을 8, 16, 24비트로 제한하여 A,B,C 클래스로 분류했다. 이러한 분류체계를 **클래스 주소체계**라고 하낟. 그러나 이러한 주소체계는 **중소형 크기의 네트워크를 사용하는 기관을 지원하기에 문제**가 있었다. **클래스 C**는 254개의 호스트만을 제공하므로 **매우 부족하고**, 클래스 B는 65,634개의 호스트를 제공하므로 **너무 컸다(효율성x).** 65,634개 중에서 2000개를 사용했을 떄 나머지 63,000개는 다른 조직이 사용할 수 없었기 때문이다. 
 IP 주소의 또 다른 형태는 255.255.255.255가 있는데 **이는 브로드캐스트 주소**로, **같은 서브넷에 있는 모든 호스트에게 전달**된다. 
 IP 주소체계를 알아봤으니 호스트와 서브넷이 **어떻게 자신의 주소를 인식하는지 알아보자** 먼저 **주소 블록을 어떻게 획득하는지**와, **어떻게 주소 블록을 장비에 할당하는지**살펴보자.
 
 
 #### 주소 블록 획득
 기관의 서브넷에서 사용하기 위한 IP 주소 블록을 얻기 위해서 **네트워크 관리자는 먼저 이미 할당받은 주소의 큰 블록에서 주소를 제공하는 ISP와 접촉해야 한다.**
```
여기서 ISP는 인터넷 서비스 제공자라는 뜻으로 IP 주소를 제공한다. 이때, ISP는 이미 큰 블록의 IP 주소를 할당받아 관리하고 있으며, 여기에 일부를 기관에 제공할 수 있다. 
```
예를 들어 200.23.16.0/20을 ISP가 할당받았을 경우 주소 블록을 8개로 나누기 위해 200.20.xx.0/23으로 나눌 수 있다. 
 **그렇다면 ISP는 어떻게 주소를 얻을까?**
 -> IP 주소 공간을 관리하고 ISP와 다른 조직에 주소 블록을 할당하는 최상위 국제기관인 **ICANN**이 있다. 이 단체의 역할은 **IP 주소 할당과 DNS 루트 서버 관리**이다. **ICANN은 지역 인터넷 등록 기관(RIRs)에서 지역 내 주소의 할당/관리를 제어하게 한다.**
 
 #### 호스트 주소 획득 : 동적 호스트 구성 프로토콜
 기관은 ISP로부터 주소 블록을 획득하여 **개별 IP 주소를 기관 내부의 호스트와 라우터 인터페이스에 할당한다**. 먼저 라우터 인터페이스 주소는 **시스템 관리자가 라우터 안에 IP 주소를 할당**한다.(종종 원격으로 수행) 호스트에 IP 주소를 할당하는 것도 **수동으로 가능하지만(static IP)**, 일반적으로 **동적 호스트 구성 프로토콜(DHCP)를 사용**한다. 호스트가 IP 주소를 자동으로 얻을 수 있게 하는 것이다. 네트워크 관리자는 해당 호스트가 네트워크에 접속하고자 할 때 _동일한 IP 주소를 받도록(DHCP 예약 또는 Static DHCP)_하거나, **임시 IP 주소(자원 효율적)**를 할당하도록 DHCP를 설정한다. 또한, DHCP는 서브넷 마스크, 첫 번째 홉 라우터(디폴트 게이트 웨이) 주소나 로컬 DNS 서버 주소 같은 추가 정보를 호스트가 얻게 해준다.

네트워크에서 자동으로 호스트와 연결해주는 DHCP 때문에 **플러그 앤 플레이 프로토콜** 또는 **제로 구성 프로토콜**이라고 한다.
 - 플러그 앤 플레이 프로토콜 : 플러그를 꽂기만 하면 바로 사용할 수 있다. 즉, 자동으로 설정이 이루어져 사용자가 별도로 설정할 필요가 없다.
 - 제로 구성 프로토콜 : 마찬가지로 설정이 필요 없는 프로토콜이라는 의미이다. 
 이는 네트워크 관리자에게 매우 유익한데, 호스트가 떠나거나 이동할 때 **DHCP는 매우 적합**하다. 
  ![](https://velog.velcdn.com/images/choiyoung6609/post/be1f0f1a-f131-4a6a-aedd-e40ae73ee052/image.png)
**DHCP는 클라이언트-서버 프로토콜이다.** 클라이언트는 일반적으로 IP 주소를 포함하며 **네트워크 설정을 포함하여 네트워크 설정을 위한 정보를 얻고자 새롭게 도착한 호스트**이다. 간단한 경우, 각 서브넷은 각자 DHCP 서버를 가질 것이다. 만약 DHCP 서버가 서브넷에 없다면, **해당 네트워크에 대한 DHCP 서버 주소를 알려줄 DHCP 연결 에이전트(일반적으로 라우터)**가 필요하다. 

 ![](https://velog.velcdn.com/images/choiyoung6609/post/0aa281c3-35c3-4e89-af1c-f097a4edb078/image.png)

위의 그림은 새로운 클라이언트가 도착할 경우, 네트워크 상에서 수행될 DHCP 프로토콜 4단계의 과정이다. 이 그림에서 **yiaddr**는 새롭게 도착한 클라이언트에 _할당될 주소_를 가리킨다. 

- DHCP 서버 발견 : 먼저 DHCP 를 찾기 위해 **DHCP 발견 메세지**를 보낸다. 이때 브로드캐스르로 보내며 포트는 67번을 쓰고, UDP-IP 패킷을 사용한다. 자신의 IP 주소도 모르고, 해당 네트워크의 DHCP 서버도 모르기 때문에 **자신의 주소는 0.0.0.0으로 설정하고, 목적지는 브로드캐스트인 255.255.255.255로 보내는 것**이다. 
- DHCP 서버 제공 : DHCP 발견 메세지를 받은 DHCP 서버는 **DHCP 제공 메세지를 클라이언트에게 보낸다** 이때에도 다시 **IP 브로드캐스트 주소 255.255.255.255를 사용하여 보낸다. - 클라이언트가 아직 유효한 주소를 가지고 있지 않아서** (0.0.0.0은 아직 IP를 할당받지 못한 상태를 의미한다) 서브넷는 여러 DHCP 서버가 존재하기 때문에 **여러 DHCP 제공 메세지로부터 가장 최적의 위치에 있는 DHCP서버를 선택**한다. 각각 메세지에는 _수신된 발견 메세지의 트랜잭션 ID, 클라이언트에 제공된 IP 주소, 네트워크 마스트크, IP 주소 임대 기간_을 포함한다. 임대기간은 보통 몇 시간에서 며칠이다.
- DHCP 요청 : 클라이언트는 하나 또는 그 이상의 서버 제공자 중에서 적합한 DHCP를 선택할 것이고, IP 주소와 기타 설정 매개변수를 포함하여 **DHCP 요청 메세지**로 응답할 것이다.(IP 주소와 설정값 맞는지 확인)
-DHCP ACK : 서버는 DHCP 요청 메세지에 대해 요청된 파라미터를 확인하는 **DHCP ACK 메세지**로 응답한다.

 이후에 클라이언트는 임대 기간동안 할당 IP 주소를 사용할 수 있다. 또한, 계속 이 주소를 사용할 경우를 위해 **DHCP는 IP 주소 임대를 갱신할 수 있느 메커니즘을 제공**한다. 
 
 이동성 측면에서 **DHCP는 큰 결점이 하나**있다. 노드가 새롭게 연결될 때 DHCP를 통해 새로운 주소를 얻기 때문에 **원격 애플리케이션에 대한 TCP 연결은 유지될 수 없다** - 7장에서 셀룰러 네트워크가 지속적인 TCP 연결을 유지하는 방법에 대해 배울 것이다. 
 
### 3.3 네트워크 주소 변환(NAT)
 앞에서 인터넷 주소와 IPv4를 살펴본 것처럼, 모든 IP 활용 장치에는 **IP 주소가 필요**하다. SOHO 네트워크의 확산으로 인해 SOHO가 장치를 연결하기 위해 LAN을 설치할 때마다 **ISP는 모든 SOHO의 IP 장치를 수용할 수 있는 주소 범위**를 할당해야 한다. 네트워크가 커지면 큰 주소 블록이 할당되어야 한다. 하지만 ISP가 이미 SOHO 네트워크의 해당 주소 범위에 인접한 부분을 할당했으면 어떻게 될까? 예를 들어서, SOHO A에도 192.168.1.0/24를 할당하고, SOHO B에도 192.168.1.0/24를 할당한 것이다. 즉, 둘 다 동일한 **사설 IP 주소 범위를 사용**하고 있다. 또한, 특정 네트워크 소유자가 IP 주소가 어떻게 관리하는지 알고리자 한다면? 이때 사용하는 것이 바로 **네트워크 주소 변환(NAT)이다.**

![](https://velog.velcdn.com/images/choiyoung6609/post/dfa6ec73-2b72-4acf-af88-b2a40036b866/image.png)

다음은 **NAT 가능 라우터**를 보여준다. NAT 가능 라우터는 홈 네트워크의 일부인 인터페이스를 갖는다. 홈 네트워크의 인터페이스는 모두 같은 네트워크 주소인 **10.0.0.0/24**를 갖는다. 이때, 10.0.0.0/8 범위는 **사설망** 또는 **사설 개인 주소를 갖는 권역**을 위해 [RFC 1918]에 예약된 IP 주소 공간 세 부분 중 하나이다. 나머지 두 범위는 172.16.0.0/12거나 192.168.0.0/16이다. 

여기서 **"사설 주소를 갖는 권역"**이란 그 네트워크 내부에 있는 장비에게만 의미가 있는 네트워크란 의미이다. 많은 홈 네트워크에서 같은 주소 공간 범위(10.0.0.0/8)를 사용하고 있기 때문에 사실 외부에서 소통하기 위해서는 이 주소를 사용할 수 없다(겹치기 때문에) **내부에서 소통할 때는 10.0.0.0/8 주소 체
체계를 사용하여 소통**하지만, 외부와 소통하기 위해서는 다른 방법을 사용해야 한다. 그렇다면 외부와 소통하기 위해서는 어떻게 해야 할까? 

정답은 바로 **NAT**을 사용하는 것이다. NAT 가능 라우터는 외부에서는 **라우터처럼 보이지 않는다.** 대신에 **하나의 IP 주소를 갖는 하나의 장비로 동작**한다. 따라서 위의 그림과 같이 출발지 IP 주소와 돌아오는 트래픽의 목적지 주소가 138.76.29.7인 것이다(NAT 가능 라우터의 주소). 이때 NAT 가능 라우터는 외부에서 들어오는 홈 네트워크의 상세한 사항을 숨긴다.(라우터는 ISP의 DHCP 서버로부터 주소를 얻고, NAT-DHCP-라우터로 제어되는 홈 네트워크의 주소 공간에서 "DHCP 서버"를 실해아형 컴퓨터에게 주소를 제공한다.) 즉, 이 라우터를 통해 **DHCP 서버가 제공되어 사설 IP 주소를 자동으로 할당**받는다. 

WAN에서 같은 목적지 IP 주소를 갖는 NAT 라우터에 모든 데이터그램이 도착하면, 라우터는 **NAT 변환 테이블**을 사용하여, 내부 호스트를 파악한다. 

예를 들어 내부 호스트(원래 포트 번호 : 3345)에 새로운 출발지 포트 번호(ex) 5001)을 할당하고, IP 주소를 공용 IP 주소(라우터 IP 주소)로 변환한 다음에 보낸다. (**16비트까지 포트 번호 사용 가능, NAT 변환 테이블에 엔트리 추가**) 이후 NAT 라우터에서는 전달된 데이터그램의 **목적지 IP 주소와 목적지 포트 번호**를 사용하여, **내부 브라우저로 전달되기 위한 적절한 IP 주소와 포트 번호**로 변환한다. 

NAT 주소는 최근에 폭넓게 쓰이지만 반대하는 사람이 없는 것은 아니다. 그 이우는 **포트 번호가 호스트 주소 지정이 아니라 프로세스 주소 지정에 사용된다**는 것이다. 
- 호스트 주소 지정 : 특정 장치를 식별하기 위해 사용하는 것. 
- 프로세스 주소 지정 : 특정 애플리케이션이나 서비스를 식별하기 위해 사용하는 것. (HTTP는 80번)

즉, 포트 번호는 호스트를 구분하기 위한 것이 아니라 원래 **프로세스를 구분**하기 위한 것이었다. 이러한 위반으로 인해 **서버가 제대로 작동하지 않을 수 있**다. 예를 들어 서버 프로세스가 잘 알려진 포트 넘버를 열고 클라이언트를 기다리고 있거나, P2P 프로토콜에 있는 피어들이 서버로서 동작하고자 할 때 문제가 발생한다. 예를 들어, 클라이언트가 203.0.113.1:80으로 HTTP 요청을 보냈을 때, 이 주소가 다시 내부 네트워크의 사설 IP 주소와 포트 번호로 변환되어야 한다. 즉, 포트 80으로 오는 요청을 내부 서버의 192.168.1.10:80으로 보내야 한다. 그러나, 이러한 포트 포워딩이 제대로 설정되지 않으면, NAT 라우터는 외부 요청을 올바른 내부 장치로 전달하지 않으므로 클라이언트가 서버에 적븍ㄴ할 수 없다. 
그렇다면 **한 피어가 NAT 서버 뒤에 있고, DHCP 제공 NAT 주소가 있는 다른 피어에 어떻게 연결할 수 있을까?** 이 문제를 해결하기 위해서는 기본적으로 **NAT 순회 도구**가 있다.(직접 연결)

### 3.4 IPv6
IPv6 개발의 주요 동기는 빠른 속도로 고갈되어 가는 IPv4 주소 공간 때문이었다. 현재는 IPv6와 IPv4를 같이 사용하고 있다.

#### IPv6 데이터그램 포맷
![](https://velog.velcdn.com/images/choiyoung6609/post/d630fb5b-1706-413e-a30a-7231824e79a4/image.png)

IPv6에서 확장된 기능은 다음과 같다.
- **확장된 주소 기능** : 기존에 IP 주소 크기를 32비트에서 128비트로 확장해서 더 이상 주소 공간이 고갈되는 일은 발생하지 않을 것이다. 또한, 유니캐스트, 멀티캐스트 뿐만 아니라 **애니캐스트 주소**가 도입되었다. 애니캐스트 주소로 명시된 데이터 그램은 **호스트 내의 어떤 이에게든 전달될 수 있다.**
- **간소화된 40바이트 헤더** : IPv4의 많은 필드가 생략되고 옵션으로 남겨졌다. **40바이트로 고정된 헤더는 라우터가 데이터그램을 더 빨리 처리하게 해준다.**
- **흐름 레이블링** : IPv6는 정의하기 어려운 **흐름**을 가지고 있다. 즉, 특별한 처리를 요청하는 송신자에 대해 특정 흐름에 속하는 패킷 레이블링을 가능하게 하는 것이다. 예를 들어, 비디오 전송은 흐름으로 처리, 높은 사용자 우선순위를 가지고 전달된 트래픽은 흐름으로 처리될 수 있다. 

IPv6에는 다음과 같은 필드가 있다.
- 버전 : IP 버전 정보를 표시하는데 이 필드값은 6이다.
- 트래픽 클래스 : IPv4에서 TOS와 유사한데 예를 들어 흐름 내의 SMTP 같은 데이터그램보다 VoIP 같은 데이터 그램에 더 우선순위를 부여하는 것 이다.
- 흐름 레이블 : 이 20비트 필드는 데이터그램의 흐름을 인식하는데 사용된다.
- 페이로드 길이 : 이 16비트는 헤더 뒤에 나오는 페이로드의 바이트 길이이다.
- 다음 헤더 : 데이터그램이 전달될 프로토콜(TCP나 UDP)를 구분한다.(프로토콜 필드와 같다)
- 홉 제한 : 라우터가 데이터그램을 전달할 때마다 1씩 감소한다.(TTL 필드)
- 출발지와 목적지 주소 : 128비트 형태
- 데이터 : 데이터그램이 목적지에 도착하면 IP 데이터그램의 페이로드를 다음 헤더 필드에 명시한 프로토콜에 전달한다. 

그리고 IPv4와 IPv6를 비교했을 떄 IPv6에서 사라진 몇몇 필드들이 있다.
- 단편화/재결합 : IPv6에서는 단편화와 재결합을 출발지와 목적지에서만 수행한다. 즉, 너무 크다면 라우터는 **데이터그램을 폐기하고 ICMP 오류 메세지를 보낸다**. 그러면 송신자는 IP 데이터그램의 크기를 줄여서 다시 보낸다. **단편화/재결합은 시간이 오래 걸리므로 라우터에서 이 기능을 삭제**했다.
- 헤더 체크섬 : 트랜스포트 계층과 데이터 링크 프로토콜에서 체크섬을 수행하므로 IP 계층에서는 이를 생략했다. 즉, **빠른 처리**를 위주로 생각했다느 것이다.
- 옵션 : 표준 IP 헤더 필드는 아니지만 **완전히 사라진 것은 아니다** 대신 옵션 필드는 **다음 헤더**중 하나가 될 수 있다. 즉, 옵션 필드도 **다음 헤더 필드에서 지칭**될 수 있어, 옵션 정보를 포함할 수 있다. 

#### IPv4에서 IPv6로의 전환
![](https://velog.velcdn.com/images/choiyoung6609/post/26acd0af-da2f-4310-a400-1cd27e81b4ad/image.png)

IPv4를 기반으로 한 인터넷이 어떻게 IPv6로 전환될 수 있을까? 이미 IPv4로 구축된 시스템은 IPv6 데이터그램을 처리할 수 없다는 것에서 문제가 발생한다.

이를 해결하기 위해서는 **플래그 데이**를 설정하여 모든 인터넷 장비를 끄고 한번에 IPv4를 IPv6로 바꾸는 것이다. 사실상 불가능하다.
실제로 사용되는 방법은 **터널링**이다. IPv6 노드가 IPv6 데이터그램을 사용해서 작동할 때 그 사이 IPv4를 통해 연결되어 있다고 하자. 이러한 IPv4 라우터들을 **터널**이라고 한다. 터널의 송신 측에서의 IPv6노드는 IPv4 데이터그램의 데이터 필드에 이를 넣는다. 그리고 IPv4의 데이터그램에 **목적지 주소를 터널의 수신 측의 IPv6노드**로 적어서 넣는다. 터널 안에선는 IPv4를 처리하는 형식으로 진행되다가 터널 수신 측에 있는 IPv6 노드는 IPv4 데이터그램을 받고 **이 데이터그램이 실제 IPv6 데이터그램임을 보면 IPv4의 페이로드를 IPv6의 데이터그램으로 만든다.** 
