## 4.2 라우터 내부에는 무엇이 있을까?
- 포워딩과 라우팅의 중요한 차이점과 네트워크 계층의 서비스와 라우터의 입력 링크에서 적절한 출력 링크로 패킷을 실제로 전달하는 기능을 살펴보자!


- **입력 포트** : 입력 포트의 맨 왼쪽 박스와 출력 포트의 맨 오른쪽 박스는 입력 링크로, _물리 계층 기능_을 수행한다. 즉, 물리적 신호를 처리하는 일을 하는데 반대편에 있는 링크 계층과 상호 운용하기 위해서 _필요한 링크 계층 기능_을 수행하기도 한다. **입력 포트에서 가장 중요한 점은 검색 기능을 수행한다**는 것이다.(가장 오른쪽 박스) 여기서 포워딩을 진행하며, 제어 패킷(라우팅 프로토콜 정보를 전달하는 패킷)은 입력 포트에서 라우팅 프로세서로 전달된다. 

- **스위치 구조** : 스위치 구조는 라우터의 입력 포트와 출력 포트를 연결한다. 

- **출력 포트** : 스위치 구조에서 수신한 패킷을 저장하고 필요한 필요한 **링크 계층과 물리 계층 기능**을 행하여 출력 링크로 패킷을 전송한다. _링크가 만약 양방향이라면 출력 포트는 동일한 링크의 입력 포트와 한 쌍을 이룬다**

- **라우팅 프로세서** : 라우팅 프로세서는 **제어 평면 기능**을 수행한다. 즉, 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 포워딩 테이블을 계산하거나(기존 라우터), 원격 컨트롤러와 통신하여 계산된 포워딩 테이블 엔트리를 수신하고 입력 포트에 설치하는 기능을 한다.(SDN 라우터)

![](https://velog.velcdn.com/images/choiyoung6609/post/4a9aad30-0e76-4887-8f33-00089a08095e/image.png)

라우터의 입력, 출력 포트와 스위치 구조는 대부분 하드웨어로 구현되는데, 데이터를 매우 빠르게 처리해야 하기 때문에(나노초 단위) 하드웨어로 구현한다. 그러나, 라우터의 제어 기능은 밀리초 단위로 작동하기 때문에(+복자한 계산) 소프트웨어로 구현되었다. 


라워터 내부를 알아보기 전에 포워딩의 종류를 좀 더 알아보자. (목적지 기반 포워딩, 일반화된 포워딩)

- **목적지 기반 포워딩** : 자동차가 최종 목적지를 표시했을 때 검색을 통해 목적지를 찾고 최종 목적지를 위해 출력 포트를 결정해준다. 

- **일반화된 포워딩** : 목적지 외에도 여러 가지 요인으로 인해 출구 포트를 결정할 수 있다. 패킷의 출발지(국가, 주)에 따라 출구가 결정될 수도 있다. 또한, 부적절한 패킷은 차단되거나, 통과하지 못할 수도 있다. (임의의 많은 요인이 출구를 선택하는 데 관여) 


![](https://velog.velcdn.com/images/choiyoung6609/post/c4756bbf-91c1-4334-aeac-9a0b71d6310f/image.png)

### 1. 입력 포트 처리 및 목적지 기반 전송

 입력 포트의 맨 오른쪽은 입력 링크와 연결되어 있어서 입력 포트의 라인 종단 기능과 링크 처리 계층은 **라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현**한다. 

 입력 포트에서 행해지는 **검색**기능은 라우터 동작의 핵심 기능이다. 라우터는 포워딩 테이블을 사용하여 도착 패킷과 관련된 출력 포트를 검색한다.
 이러한 포워딩 테이블은 라우팅 프로세서에서 계산되어 갱신되거나 원격 SDN 컨트롤러에 의해 포워딩 테이블이 수신된다. 포워딩 테이블은 라우팅 프로세서에서 입력 랑니 카드로 복사되고, 각 라인 카드에서 섀도 복사본을 다른 입력 포트로 보내어 **중앙 집중식으로 호출하지 않아, 병목 현상을 피한다.**
 
 만약 **목적지 기반 포워딩**이라고 생각해보자.(간단) 32비트 IP 주소의 경우 포워딩 테이블을 억지로 구현시키면 모든 가능한 목적지 주소마다 하나의 엔트리가 필요하다. (32비트 정수값은 0부터 4,294,967,295이므로) 그러나 40억개의 주소를 포워딩하는 것은 불가능하다. 
 
 이 문제를 해결하기 위해 다음과 같이 처리하였다. 예를 들어 4개의 링크가 있으며 패킷을 다음과 같이 링크 인터페이스로 전달한다고 가정해보자
 
 ![](https://velog.velcdn.com/images/choiyoung6609/post/46a68751-1a9d-4770-8ba9-22fc686621b1/image.png)

40개의 엔트리가 필요하지 않고, 4개의 링크 인터페이스를 통해 패킷을 나눌 수 있다. 즉, **4개의 엔트리를 갖는 포워딩 테이블**이면 된다.

![](https://velog.velcdn.com/images/choiyoung6609/post/79d658f5-06ce-4e4b-a877-85cd8419e1a9/image.png)

위의 목적지 주소 범위에서 **프리픽스**만 추출해 테이블의 엔트리와 매치한 것이다. 이때, 목적지 주소가 여러 엔트리에 매치되는 경우 **최장 프리믹스 매치 규칙**을 사용한다. 즉, 테이블에서 가장 긴 매치 엔트리를 찾고, 그 엔트리와 매치되는 링크 인터페이스로 패킷을 보내는 것이다.(가장 길게 일치하는 엔트리)

검색 기능은 개념적으로 간단한데 하드웨어 로직(입력 포트는 하드웨어)에서는 포워딩 테이블을 검색해 가장 긴 프리픽스와 매치되는 것을 찾는다. 그러나, 이는 기가바이트 전송률일때 나노초 단위로 수행되어야 한다. 따라서, 하드웨어 검색 뿐만 아니라, 대형 테이블을 통한 단순 선형 검색 이외에 **빠른 검사 알고리즘**을 사용해야 한다. 또한, 메모리 접속 시간에도 주의가 필요해서 내장형 DRAM이나 빠른 SRAM 메모리가 있거나, TCAM을 사용하기도 한다.(TCAM : 일정 시간동안 해당 주소에 대한 포워딩 테이블 엔트리 내용을 반환)

 검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낸다. 일부 설계에서는 다른 입력포트로부터의 패킷이 현재 스위치 구조를 사용하고 있다면 패킷이 스위칭 구조로 들어가는 것을 _일시적으로 차단_하고, 입력 포트에 대기한 다음 나중에 **구조를 교체하도록 예약된다**.여기서 교체라는 표현은 물리적인 교체라기 보다는 패킷이 스위치 구조로 들어가도록 예약된다는 의미이다. 
 
 입력 포트에서 검색은 중요한 기능이기는 하지만, 다른 많은 조치도 필요하다. 1) 물리 및 링크 계층 처리 2) 패킷의 버전 번호, 체크섬, TTL 필드 확인 후 다시 사용 3) 네트워크 관리에 사용되는 카운터(수신된 IP 데이터그램의 수)를 갱신해야 한다. 
 
 매치한 다음 출력 포트로 전송하는 행위는 네트워크 장비에서 많이 수행되는 일반적인 **매치 플러스 액션**의 사례이다. ex) 링크 계층 라우터, 방화벽, 네트워크 주소 변환(NAT) 등이 있다. 
 
 ### 2. 스위칭 
 스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 스위칭(포워딩)되는 구조를 통과하므로 라우터의 핵심이다. 
 
 #### 라우터를 통한 교환
![](https://velog.velcdn.com/images/choiyoung6609/post/237270e3-8410-4d3e-85f9-8c878d34f008/image.png)

가장 단순한 초기 라우터는 **라우터 프로세서(CPU)를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭했다.** 즉, 패킷이 도착하면 입력 포트는 라우팅 프로세서에 인터럽트를 보내 패킷을 프로세서 메모리에 복사하고, 라우팅 프로세서에는 헤더에서 목적지 주소를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 출력 포트에 복사한다. 이때 메모리 대역폭이 초당 최대 B라면(메모리 읽기/쓰기) 전체 전달 처리량은 B/2보다 작아야 한다. 읽고 쓰는데 B/2씩 쓰는데, 혹시 모를 오차 때문에 B/2보다는 작게 하는 것이 좋다. 또한, 목적지 포트가 다르더라도 공유 시스템 버스를 통해 보내고, 한 번에 하나의 메모리 읽기/쓰기 작업을 할 수 있기 때문에 두 패킷을 동시에 보낼 수는 없다.

최근 일부 라우터에서는 메모리를 통해 스위칭하는데 초창기와 다르게 입력 라인에서 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장한다. 따라서, 라우팅 프로세서에서는 단순히 패킷을 저장한 다음 출력 링크가 비워져 있을때(처리하는 것이 없을 때) 패킷을 보내기만 하면된다. 

#### 버스를 통한 교환

![](https://velog.velcdn.com/images/choiyoung6609/post/5d540a9c-ad85-4bb8-86b4-b60f0b2b42f6/image.png)

라우팅 프로세서의 개입 없이 **공유 버스를 통해 직접 패킷을 전송**한다. 이는 입력 포트에서 이미 **스위치 내부 레이블(헤더)을 패킷에 붙여서 출력 포트를 나타내고, 패킷을 버스로 전송한다.** 모든 출력 버스에 패킷이 수신되지만, 패킷에 있는 라벨과 매치되는 포트만 패킷을 유지한다. 레이블은 스위치에서만 사용되기 때문에 출력 포트에서 제거된다. 이 또한, 공유 버스를 사용하기 떄문에 **한 번에 하나의 패킷만 전달한다** 

#### 상호 연결 네트워크를 통한 교환
![](https://velog.velcdn.com/images/choiyoung6609/post/3eebf44c-a1f3-4ee2-a29d-9dbdf14aaae5/image.png)

공유 버스의 대역폭 제한이라는 단점을 극복하는 방법 중 하나는 좀 더 복잡한 상호연결을 하는 것이다. **크로스바 스위치**는 N개의 입력 포트와 N개의 출력 포트에 연결하는 2N개의 버스들로 구성되어 있다. 각 수직 버스는 교차점에서 각 수평 버스와 교차하면서 **스위치 구조 컨트롤러**에 의해 언제든지 열거나 닫을 수 있다. 패킷이 A에서 Y로 가는 경우, 스위치 컨트롤러는 A와 Y의 교차점에서 교착점을 닫고, 포트 A가 패킷을 버스로 보낸다. 때, 여러 패킷이 동시에 전달될 수 있지만 같은 출력 포트로 전달되는 패킷일 경우 한 번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야 한다. 
 이 뿐만 아니라 다단계 스위치 구조를 통해 **동일한 출력 포트를 향해 동시에 전달될 수 있도록 여러 단계의 스위칭 요소를 사용**한다. 
 
 ### 3. 출력 포트 처리
 출력 포트 처리는 출력 포트 메모리(버퍼)에 저장된 패킷을 가져와서 출력 링크를 통해 전송하는 것이다. 따라서,** 패킷 선택(스케쥴링), 큐 제거, 필요한 링크 및 물리 계층 전송 기능을 수행하는 것**이 중요하다. 
 
 ### 4. 어디에서 큐잉이 일어날까?
 패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있다. 큐의 위치와 범위는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라서 달라진다. 큐보다 더 많은 패킷이 들어오면 메모리 범위보다 더 커져서 **패킷 손실**이 발생하기 때문에 큐에 대 더 공부해봐야 한다. 
 먼저 입출력 라인 속도(전송률은) R로 동일하고, N개의 입력과 출력 포트가 있다고 가정하자. 또한, 모든 패킷의 길이가 똑같고 패킷이 동기식으로 업데이트되기 때문에(일정 시간마다 입력 포트에 도착) 링크 상에서 패킷 송신하는 시간과 수신하는 시간이 동일하다.(링크 상에서 지연 없음) 따라서, 0개나 한 개의 패킷이 입력 링크로 도착할 수 있다. 스위치 구조 전송률을 Rswitch라고 했을 때, 입력 라인의 전송률인 Rline보다 N배 빠르다면, 스위치 구조에서 빠르게 전달하는 것이기때문에 **입력 포트에서의 큐잉이 사라진다.** 그 이유는 N개의 패킷이 같은 출력 포트에 전달될 때 N개의 패킷을 빠르게 처리하여 다음 배치 작업이 도착하기 전까지 모두 처리하여 삭제할 수 있기 때문에 입력 큐잉의 의미가 없다. 
 
 #### 입력 큐잉
 만약 스위치 구조가 **모든 패킷을 전송하기에 충분히 빠르지 않다면 어떻게 해야 될까?**
 
-> 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야 한다. 

먼저 스위치 구조가 크로스바 스위치 구조이고, 1) 모든 링크의 속도는 같으며, 2) 입력 링크가 패킷을 받는 것과 같은 속도로 입력 포트에서 출력 포트로 전달되며, 3) FCFS 방식으로 입력 큐에서 출력 큐로 이동된다고 하자. 
출력 포트가 다르다면 **병렬로 전달될 수 있지만, 출력 포트가 같다면 한 패킷은 차단되고 기다려야 한다.**

![](https://velog.velcdn.com/images/choiyoung6609/post/ebc3c744-b9c8-4647-b256-456ea1b43ef9/image.png)

위의 그림을 한 번 살펴보자.
첫 번째 입력 포트와 세 번째 입력 포트에서 진한 청색 패킷(맨 앞쪽)은 같은 출력 포트로의 이동을 원하고 있다. 첫 번째 입력 포트에서의 패킷이 먼저 전달된다고 했을 때, **세 번째 패킷에서의 패킷은 대기해야 한다.** 또한, 세 번째 입력 포트에서 두 번째 패킷은 출력 포트가 겹치지 않지만, 바로 앞의 퍀킷 때문에 기다려야 한다. **이 현상을 입력 대기 중인 스위치에서의 HOL(head-of-the-line)이라고 한다.** 입력 포트 라인의 앞쪽에서 다른 패킷을 막고 있기 떄문에 출력 포트가 겹치지 않아도 대기해야 하는 것이다. _[Karol 1987] 은 입력 링크에서 패킷 도착 속도가 용량의 58%가 되면 HOL 차단 때문에 입력 큐가 무한정 길이로 증가함을 보여준다.(패킷 손실)_


#### 출력 큐잉
다음으로 출력 포트에서 큐잉이 발생하는지 여부를 판단해보자. R 스위치가 Rline 전송률보다 N배 빠르고, 각각 입력 포트의 패킷이 동일한 출력 포트로 이동한다고 가정해보자. 이때, 출력 링크에 하나의 패킷을 보내는 시간에 N개의 패킷이 쌓인다. 이때, 출력 링크로 하나만 처리 가능하기 때문에 **출력 ㄹ이크를 통한 전송 큐에서 대기**해야 한다. 이렇게 되면 결국 **출력 포트에서 모든 메모리를 다 소모할 만큼 충분히 패킷의 수가 많아질 수 있다(패킷 손실)**

이렇게 큐보다 더 많은 패킷이 들어오는 경우 **도착한 패킷을 삭제하거나 대기 중인 하나 이상의 패킷을 제거하여 새로운 패킷을 저장하는 정책**을 실행한다. _어떤 경우에는 버퍼가 가득차기 전에 패킷을 삭제 하여 송신자에게 혼잡 신호를 보낸다._ 이는 명시적 혼잡 알림(ECN) 비트를 사용하여 수행할 수 있다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/4c2de4cd-9857-4b03-9aef-f067c245eb58/image.png)
AQM 알고리즘으로 알려진 패킷 삭제와 패킷 마킹 정책이 제안되거나 분석되고 있다. (RED 또는 PIE, CODEL)
위의 그림에서는 시간 t동안 한 번에 모든 패킷이 쌓이는 모습을 보여준다. 다음 번에는 이 세 패킷 중 하나는 출력 라인을 통해서 전송될 것이다. 또한, 2개의 새로운 패킷 중 하나는 다시 같은 출력 포트로 전송될 것이다. 이때, 출력 라인을 통해서 전송될 패킷은 **패킷 스케쥴러를 통해서 선택된다.**

#### 얼마나 많은 버퍼가 요구되는가?
위에서 큐가 어떻게 형성되고 길어지는지를 알아봤다. 또한, 포트의 버퍼가 가득차서 삭제해야 하는 경우도 있다는 것을 살펴봤다. **그렇다면 얼마나 많은 버퍼링이 제공되어야 하는가?라는 의문이 생긴다.**

몇 년동안 [RFC 3439]에서 정한 버퍼 크기 규칙은 링크 용량이 C일 때, 버퍼링의 양은 평균 왕복 시간(RTT)와 링크 용량(C)를 곱한 값과 같아야 한다는 것이다. 즉 250ms(RTT) * 10Gbps = 2.5Gb이다. 이 결과는 **상대적으로 작은 양의 TCP 흐름에 대한 큐잉 분석**에 기반을 둔다. <tcp 흐름이 별로 없을 때 사용한다는 의미> 그러나, **많은 수의 TCP 흐름(N)dㅣ 링크를 통과할 때 필요한 버퍼링은 _B = RTT * C / (루트(N))_으로 정했다.** 많은 수의 TCP 흐름이 있는 코어 네트워크에서 N 값은 커질 수 있으며 버퍼 크기의 감소가 상당히 두드러진다. 

이렇게 하는 이유는 버퍼링이 라우터의 패킷 손실을 감소시키는 장점보다 버퍼가 클수록 **큐잉 지연이 길어진다**고 생각하면 된다. 패킷 손실을 줄이기 위해 버퍼의 양을 10배 늘리면 종단 간 지연이 10배만큼 증가하게 되고, **증가된 RTT는 TCP 송신자의 초기 혼잡 또는 패킷 손실에 대한 응답 속도를 떨어뜨린다.** 

지금까지 _많은 사용자가 혼잡한 링크에서 대역폭과 버퍼를 놓고 경쟁하고 있다고 가정했다._ 이는 네트워크 코어에서는 훌륭한 가정이지만 **네트워크 가장자리에서는 유지되지 않을 수 있다.** 

![](https://velog.velcdn.com/images/choiyoung6609/post/58392ee5-f1c4-4015-8339-d34b2a7f3fd2/image.png)

위의 그림은 게이머의 tcp 세그먼트를 게임 서버로 보내는 그림이다. 게이머의 tcp 세그먼트를 포함하는 패킷을 전송하는데 20ms가 소요되며 큐잉 지연은 무시해도 된다. RTT는 200ms이다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/5aa0fa34-0e71-4111-a5ad-32cc1df6f1ce/image.png)

그림과 같이 t = 0에서 25개의 패킷 버스트가 큐에 도착한다고 가정하자. 위의 그림에서 오차가 있는데 200ms에서 일 때 11번째 패킷이 전송되고 있으며, 이때 처음으로 ACK가 도착한다. 이 도착은 tcp 송신자가 새로운 패킷을 다시 큐 안으로 집어 넣게 된다. 220ms에도 마찬가지로 다음 ACK가 도착하고, 22번째 패킷을 전송함과 동시에 송신자가 새로운 패킷을 큐 안에 넣는다. 따라서, 일정 시간이 지난 이후에는 항상 패킷의 양이 15개로 일정하게 유지된다. 따라서, 종단 간 파이프(송신자와 수신자 사이의 전체 네트워크 경로)는 꽉 찼지만, **큐잉 지연은 일정 시간 이후에 일정하고 지속적이다.** _그 결과 게이머는 홈 네트워크에 다른 트래픽이 존재하지 않음에도 불구하고 지연이 지나치게 긴 이유를 이해하지 못하게 된다._ **이렇게 지속적 버퍼링으로 인한 긴 지연에 대한 위의 시나리오를 버퍼블로트라고 한다.** 이는 처리량 뿐만 아니라 **최소 지연도 필요**하며 네트워크 가장 자리와 네트워크 내 큐에서 송신자 간의 상호작용이 실제로 복잡하고 미묘할 수 있음을 보여준다. **버퍼의 길이가 너무 큰 경우 발생**

### 5. 패킷 스케쥴링
큐에 있는 패킷이 출력 링크를 통해서 전송되는 순서를 결정하는 문제를 **패킷 스케쥴링**이라고 한다. 대표적으로 FIFO, 우선순위 큐잉, 라운드로빈이 있다.

#### FIFO
![](https://velog.velcdn.com/images/choiyoung6609/post/58698f44-642d-4b7a-8f8a-2ca102aaf0cc/image.png)
![](https://velog.velcdn.com/images/choiyoung6609/post/23a3b203-6a55-44d0-9341-2cb766c4f370/image.png)

FIFO는 간단하게 가장 먼저 도착한 패킷을 가장 먼저 처리하는 스케쥴링 방법이다.(도착 시간에 따라 결정)

#### 우선순위 큐잉
먼저 큐에 패킷이 도착하면 우선순위에 따라 우선순위 클래스로 분류한다. **각 우선순위 클래스에는 일반적으로 고유한 큐가 있다.**
![](https://velog.velcdn.com/images/choiyoung6609/post/5262ad95-c414-4b65-83f2-ca5ac29b1513/image.png)
![](https://velog.velcdn.com/images/choiyoung6609/post/897b98aa-a700-4d2e-8900-665189c503a0/image.png)

**우선순위 큐잉에서는 가장 우선순위가 높은 패킷을 전송하고, 모든 패킷의 우선순위가 같은 경우 FIFO 방식으로 행한다.** 또한, **비선점 우선순위 큐잉**이기 때문에 패킷의 전송이 시작되면 중단되지 않아서 중간에 우선순위가 높은 패킷이 들어와도 멈추지 않는다. 

#### 라운드로빈과 WFQ
라운드 로빈 큐잉 규칙에서는 우선순위 큐잉과 마찬가지로 여러 클래스로 구분한다. 그러나, 클래스 간에 우선순위가 존재하지 않아서 클래스 간에 서비스를 **번갈아 가면서 제공**한다. 또한, **작업 보존 큐잉 규칙**의 경우, 전송을 위해 큐잉에서 기다리는 패킷이 있다면 링크가 유휴 상태가 되는 것을 허용하지 않는다.
![](https://velog.velcdn.com/images/choiyoung6609/post/f4b06c21-dfbe-4bd6-b539-f86593e2d42e/image.png)

라운드 로빈 큐잉에서 일반화된 형태는 소위 **WFQ**라고 불리는 규칙이다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/56ee841e-81ba-4f14-80f1-55b2857d6705/image.png)

라운드 큐잉과 같이 클래스별 대기 영역에 분류되며 대기하며 순환 방식으로 동작하지만 **각 클래스마다 다른 양의 서비스 시간을 부여받는다** 즉, 각 클래스 i는 가중치 wi를 할당받는다. **WFQ에서는 전송할 클래스 i 패킷이 있는 동안에 클래스 i는 wi/(큐에 패킷이 있는 모든 클래스의 합) 서비스 시간을 보장받는다.** 최악의 경우에도 항상 R*wi/(모든 클래스의 합) 처리율을 갖는다. 여기서의 WFQ는 이상적인 것인데, **패킷이 이상적인 단위 데이터라는 것과 패킷 전송이 다른 패킷을 전송하기 위해 방해되지 않는다는 사실을 고려하지 않았기 때문이다.**(독립적인 전송이라고 가정)
