
## 2. 라우팅 알고리즘
**라우팅 알고리즘**은 송신자부터 수신자까지 좋은 경로를 결정하는 것이다. 보통 좋은 경로란 **최소 비용 경로**를 의미한다. 이러한 라우팅 알고리즘은 기본적으로 **잘 정의된 라우터들**이 존재해야 한다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/c6203e14-8582-4817-90a7-c38f3a85c72f/image.png)

라우팅 알고리즘을 **그래프**를 사용하여 계산한다. 라우팅 문제에서 **노드는 라우터**이고, **엣지는 물리 링크**이다. 여기서 엣지는 보통 **비용**과 함께 표현된다.(물리적 거리, 속도, 금전 비용 등) 이렇게 엣지에 비용이 계산되고 나면 자연적으로 **라우팅 알고리즘이 최소 비용 경로를 찾는 것**을 목표로 한다. 만약 모든 엣지가 **같은 비용**을 갖는다면, **최단 경로**를 찾는 알고리즘이 된다.

라우팅 알고리즘을 분류하는 기준에는 보통 세 가지가 있다.
**1. 중앙 집중형 or 분산형**
- **중앙 집중형 라우팅 알고리즘** : 중앙 집중형 라우팅 알고리즘은 모든 엣지의 비용과 노드 사이의 연결 상태와 같은 **네트워크 전체에 대한 정보**를 **완전히**가지고 있는 상태에서 계산된다. 계산 자체는 **논리적 중앙 집중형 컨트롤러나 모든 라우터 각각에서 실행**될 수 있다. 이러한 알고리즘을 **링크 상태(Link-state, LS) 알고리즘**이라고 한다. 
- **분산 라우팅 알고리즘** : 최소 비용 경로의 알고리즘이 **반복적이고 분산적**인 방식으로 수행된다. 어떤 노드도 모든 링크 비용에 대해 완전한 정보를 가지고 있지 않다. 노드는 **자신에게 직접 연결된 링크의 정보**만을 가지고 있다.이러한 알고리즘을 **거리 벡터(DV) 알고리즘**이라고 부른다. 각 노드가 다른 모든 노드까지의 거리의 추정값을 **벡터**로 유지하기 떄문이다. 이렇게 직접 라우터들끼리 반복저긍로 메세지를 교환하는 알고리즘은 **라우터들이 직접 상호작용**하는 제어평면에 더 자연스럽다.(즉, 라우터별 제어 때 사용)

**2. 정적 or 동적**
- **정적 라우팅 알고리즘** : 아주 느리게 변하는데, 종종 사람이 개입한 결과로 그렇게 됨
- **동적 라우팅 알고리즘** : 네트워크 부하나 토폴로지 변화에 따라 **라우팅 경로를 바꾼다**. **주기적으로 응답**하거나, 변화에 **직접 응답**하는 방식으로 수행되는데, **빠르게 대응**한다는 장점이 있지만, **경로의 루프나 경로 진동**에 취약하다.

**3. 부하에 민감 or not**
- **부하에 민감한 알고리즘** : 링크 비용이 **혼잡**을 나타내기 위해 **동적**으로 변한다. 
- **부하에 민감하지 않은 알고리즘** : 혼잡을 반영하지 않음(오늘날 라우팅 알고리즘)

### 2.1 링크 상태(LS) 라우팅 알고리즘
**링크 상태 알고리즘**은 알고리즘 입력값으로 이미 **네트워크의 포폴로지와 모든 링크 비용**이 들어간다. 이는 각 노드가 **직접 연결된 링크에 대한 정보**를 **모든 노드**로 **브로드캐스트**함으로써 가능하다. 실제로 **링크 상태 브로드캐스트 알고리즘**에 의해 수행된다. 
 링크 상태 알고리즘에서 **최소 비용 경로**를 정하는 알고리즘은 **다익스트라 알고리즘**을 사용한다. 이는 **하나의 노드**에서 다른 모든 노드까지의 **최소 비용을 계산**한다. **반복적**이며, k 번째 반복 이후에는 k개의 목적지 노드에 대해 최소 비용 경로가 알려진다.
 - D(v) : 출발지 노드부터 목적지 v까지의 최소 비용 경로
 - p(v) : 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드
 - N' : 노드의 집합.
 
중앙 집중형 라우팅 알고리즘(링크 상태 알고리즘)은 초기화와 반복 부분으로 구성되어 반복 부분의 수행횟수는 네트워크의 노드 수와 같다. 
```java
// 초기 출발 노드의 이웃을 추가
**Initialization:** 
        N` = ( u }
        for all nodes v
        if v is a neighbor of u
                then D(v)= c(u,v) 
        else D(v) = INF

// 거리가 최소인 노드를 방문하고 비용 갱신을 반복
**Loop**
        find w not in N` such that D(w) is a minimum
        add w to N`
        update D(v) for each neighbor v of w and not in N` :
                D(v) = min (D(v), D(w) + c(W, v))
                /* new cost to v is either old cost to v or known
                 least path cost to w plus cost from w to v     */
**until** N` = N 
```

- 초기화 단계에서는 처음 노드에서 직접 연결된 노드까지의 최소 비용 경로를 초기화한다. 만약 직접 연결되어 있지 않다면 무한대로 표시한다.
- N'에 포함되어 있지 않은 노드 중에서 이전 반복이 끝낸 시점에서 **최소 비용을 가진 노드**를 찾고 N' 집합에 추가한다.(확정) 그리고 모든 노드에 대한 D(v)를 계산한다.(n - 1) 또한, 여러 경로가 있을 때, 가장 낮은 비용을 갖는 경로가 선택된다.
- 만약 최소 경로 비용이 같은 금액일 때는 둘 중 임의로 한 개를 선택하고, N'에 넣는다. 
- 계속..

![](https://velog.velcdn.com/images/choiyoung6609/post/1c486a70-4f23-4a36-9e22-a452a62d9f18/image.png)


우리는 각 노드에 대해 **출발지 노드로부터의 최소 비용 경로상의 직전 노드**를 알게 된다. 이러한 직전 노드는 **또 다른 직전노드**를 가지기 때문에 모든 전체 경로를 구할 수 있게 된다. 
이 알고리즘의 **계산 복잡도**는 어떻게 될까?
처음에 N'에 포함되지 않는 w를 결정하기 위해 모든 n을 검사해야 한다. 그리고 점점 하나씩 줄어들어서 마지막에는 1개가 된다. 즉, n(n+1)/2을 검사하므로 **시간복잡도가 O(n^2)가 된다.

![](https://velog.velcdn.com/images/choiyoung6609/post/52440c1e-5ca7-4438-b162-72efcf5011e9/image.png)


링크 상태 알고리즘의 문제점은 **링크 비용이 트래픽 부하**를 반영할 때이다. 이 예에서 링크 비용은 대칭적이지 않다.
![](https://velog.velcdn.com/images/choiyoung6609/post/80e1b410-8ee0-4a45-993a-b77798b5ecb0/image.png)

초기의 라우팅은 a와 같이 시계 방향으로 이루어졌었다.(트래픽 1) 그래서 모든 트래픽을 다시 시계 방향으로 최소 비용 경로를 결정하고, 경로 비용을 계산하면 b처럼 된다. 따라서, **다시 반시계 방향**으로 돌아야 하는 것이다.(트래픽 0이 되려고) 그 이후 계속 **시계 방향과 반시계 방향이 반복**된다. 
이러한 문제를 **진동(oscillation) 문제**를 방지하기 위해서는 어떻게 해야 할까?
먼저 트래픽 양에 의존하지 않고 링크 비용을 계산하는 것이다. 그러나 **라우팅은 혼잡을 피하기 위한 목적**도 있기 때문에, 받아들일 수 없다. 다른 해결책으로는 **모든 라우터가 동시에 실행하지 않도록**하는 것이다. 그러나, 라우터는 실행시각을 갖게 하지 않아도 결국 자기들끼리 동기를 맞추기 때문에 서로 동기화된다. 이를 해결하기 위해서는 **각 노드가 링크 상태 정보를 송신하는 시각을 임의로 결정**하게 하면 된다. 

### 2.2 거리벡터(DV) 라우팅 알고리즘
링크 상태 알고리즘이 네트워크 전체 정보를 이용하는 알고리즘인 반면에 **거리 벡터**는 **반복적**이고, **비동기적**이며, **분산적**이다.
 하나 이상의 **직접 연결된 이웃**으로부터 정보를 받아, 계산을 수행하고, 업데이트된 정보를 다시 이웃들에게 보낸다는 점에서 **분산적**이다. 또한, 프로세스가 업데이트할 정보가 없을 때까지 계속된다는 점에서 **반복적**이다. 또한, 모든 노드가 굳이 한 번에 동작할 필요가 없다는 점에서 **비동기적**이다. 
 
DV 알고리즘을 알기 전에 중요한 관계식이 있다. 노드 x부터 y까지의 최소 비용 경로 비용을 dx(y)라고 할 때, 다음과 같은 식이 나온다.

> **dx(y) = minv{(x, v) + dv(y)}

여기서 minv는 x의 모든 이웃에 적용된다. 즉, x에서 y까지의 최소 비용은 모든 이웃 노드에 대해 c(x,v) + dv(y) 중 최솟값이 된다. 이 결과는 **다익스트라 알고리즘에서도 사용**된다.

이러한 벨만 포드식은 **각 노드 포워딩 테이블의 엔트리**를 제공한다. 벨만-포드 식의 또 다른 공헌은 DV 알고리즘에서 일어나는 이웃 간 통신의 형식을 제안한다는 점이다. 

출발지 노드를 x라고 가정할 때, x부터 y까지 최소 비용 경로 Dx(y)를 구해야 한다.
DV 알고리즘으로 각 노드 x는 다으므이 정보를 가진다.
- 각 이웃 노드 v중에서 x에 직접 접속된 이웃노드까지의 비용 c(x,v)
- 노드 x의 거리벡터, 즉 x로부터 N에 있는 모든 목적지 y까지의 비용 예측값 {Dx(y): y in N}
- 이웃 노드들의 거리벡터, 즉 v가 x의 이웃이라고 할 때 Dv = {Dv(y): y in N}

그리고 때때로 노드는 **자신의 거리벡터를 이웃에게 보낸다** 이후 x는 w의 거리벡터를 저장하고 벨만-포드식을 사용하여 **자신의 거리벡터를 갱신**한다.
만약 이때 값이 변경된다면, 다시 수정사항을 자신의 이웃 노드에게 보내고, 그에 따라 이웃들도 거리 벡터를 갱신한다. 

#### 거리 벡터(DV) 알고리즘

```java
Initialization:

   // 출발지 x로 부터 모든 목적지까지의 거리 갱신
   for all destinations y in N:
      Dx(y) = c(x, y) /* if y is not a neighbor then c(x,y) = INF */

   // x의 이웃 w들로 부터 모든 목적지까지의 거리 갱신
   for each neighbor w
      Dw(y) = ? for all destinations y in N 

   for each neighbor w
      send distance vector Dx = [ Dx(y) : y in N ] to w


loop
   wait (until I see a link cost change to some neighbor w or
      until I receive a distance vector from some neighbor W)

   for each y in N:
      Dx(y) = min_v{ c(x, v) + Dv(y) }

   if Dx(y) changed for any destination y
      send distance vector Dx = [ Dx(y) : y in N ] to all neighbors

forever
```
먼저 테이블에서는 처음에 자신의 이웃 노드들까지의 거리를 단순히 계산한다. 그리고 이웃 노드에게 자신의 상태를 알린다. **그러나, 특정 목적지 y에 대한 자신의 포워딩 테이블을 갱신하기 위해 노드 x가 정말 알아야 하는 것은 y까지의 최단 경로보다는 y 로의 최단 경로상 다음 홉 라우터인 이웃 노드 v*(y) 이다**. 이때 노드 x는 목적지 y에 대해 v*(y)를 갱신하고 이에 대한 포워딩 테이블도 갱신하는 것이다. 

즉, **이웃으로부터의 갱신을 기다리고**, **업데이트 시 거리 벡터를 계산**하고, 다시 **배포한다.**

![](https://velog.velcdn.com/images/choiyoung6609/post/fbc9cdd9-d9b4-44d5-957e-54bd8b36da58/image.png)

다음은 거리 벡터 알고리즘의 동작을 보여준다. 모든 동작은 현재 **동기적 방식**으로 이루어진다. 물론 비동기적 방식을 이용해도 알고리즘이 옳게 작동한다.

금림의 맨 왼쪽은 각각의 노드에서 최초 라우팅 테이블이다. 즉, 자신의 이웃 노드까지의 거리 값을 갱신한 상태이다. **각 행은 거리벡터로 구해진다.** 이떄는 다른 노드의 값을 모른다.

![](https://velog.velcdn.com/images/choiyoung6609/post/31c9cbba-d1de-4b50-a1c2-09b97658cafd/image.png)

두 번쨰와 세 번째 행은 y와 z로부터 받은 거리벡터이다. 
이때는 다음과 같이 계산된다.
Dx(x) = 0
Dx(y) = min{c(x,y) + Dy(y), c(x,z) + Dz(y)} = min(2 + 0, 7 + 1) = 2
Dx(y) = min{c(x,y) + Dy(z), c(x,z) + Dz(z)} = min(2 + 1, 7 + 0) = 3


![](https://velog.velcdn.com/images/choiyoung6609/post/fda72c73-7813-417f-9f5a-e84aca484d3a/image.png)

이렇게 갱신된 값들은 다시 다른 테이블로 보내진다. 여기서는 노드 x와 z만이 변화가 생겼기 때문에 얘네만 벡터를 보낸다. 그리고 다시 자신의 테이블을 업데이트한다. 

**이웃으로부터 갱신된 거리 벡터를 받고**, **라우팅 테이블 엔트리를 재계산하고, 변경값을 알리는 과정**은 갱신 메세지가 더 이상 없을 때까지 반복된다. 

#### 거리 벡터(DV) 알고리즘 : 링크 비용 변경과 링크 고장
거리 비용이 변경되면 노드는 주변에 그 사실을 알린다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/f8bc2c33-ffaf-45fa-9a54-ca5ff36b0eaf/image.png)

5.7(a)를 보면 x와 y 사이의 링크가 1로 줄어들었다. 
- 먼저 y가 이러한 비용의 변화를 알았다고 해보자. 그럼 자신의 거리 벡터를 갱신한 후 이 값을 이웃에게 알린다.(Dy(x) = 1)
- 이때, z는 x까지의 거리를 계산하는데 비용이 5에서 2로 갱신되었다. 그리고 이 것을 다시 다른 노드에 전송한다.
- y는 z로부터 갱신 정보를 받고 자신의 테이블을 갱신한다. (Dz(x) = 2) 이 후 아무런 변화가 없으므로 메세지를 보내지 않는다.

보통 링크 비용 변경은 이러한 방식으로 이루어진다. 

그러나 이제 **링크 비용이 증가**할 때를 알아보자. b처럼 x와 y사이의 링크 비용이 60으로 증가했다고 가정하자.

1. 링크 비용이 변경되기 전에 y에서 알고있는 Dy(x) = 4, Dy(z) = 1, Dz(y) = 1, Dz(x) = 5이다. y에서 다음과 같은 상태 변화를 감지했을 때 다시 값을 계산하게 되면 
Dy(x) = min{60 + 0, 1 + 5} = 6 이 된다.

물론, 이때 z를 경유하는 값이 잘못되었음을 알 수 있지만, y에서는 Dz(x)의 값이 5라고 계싼되는 것밖에 모르므로 이렇게 된다. 그 시각 y가 x를 가기 위해 y -> x가 아니라 y -> z -> x로의 경로를 선택했다. 그러나 사실 **Dz(x)는 y를 우회해서 가는 것**이었다. 즉, **라우팅 루프**에 빠지게 된 것이다.

z는 Dz(x)의 결과를 1 + 6으로 계산하여 Dz(x) = 7의 값을 계산하여 y에게 보내고 y는 다시 Dy(x) = 8임을 결정한다. 이렇게 계산식이 반복되다가 z와 y의 경로 비용 계산값이 **50을 넘을 때** 마침내 z가 Dz(x) = 50으로 설정하고 직접 연결되는 것으로 바뀐다. 이를 y에게 알리면 Dy(x) = 51이 된다. 이렇게 **링크 비용 증가**는 천천히 알려진다. 이러한 문제를 **무한 계수 문제**라고 한다.

#### 거리 벡터 알고리즘 : 포이즌 리버스 추가
방금 발생한 **라우팅 루프**시나리오는 **포이즌 리버스(poisoned reverse)** 방식으로 해결할 수 있다. 만약 z가 y를 통해 목적지 x로 간다고 "결정"했다면, y에서 다시 z로 돌아오지 못하도록 Dz(x) = 무한대 라고 설정하는 것이다. 그렇게 되면 y입장에서는 **무조건 x로 가는 수**밖에 없다.(z -> y -> x 임을 z에서 변경하지 않는 동안에는)

위의 예시에서는 처음에 Dz(x)의 값이 무한대라고 설정한다. 그러면 y에서 Dy(x)는 60이 되고 이를 다시 z에게 알리면 Dz(x) 50이 되며, 이를 알게 된 y가 Dy(x)를 51로 바꾼다. 이제 y(x)는 y -> z -> x 순이므로, Dy(x)는 무한대라고 알림으로써 z의 역경로를 차단한다. 

그러나 **포이즌 리버스** 문제도 모든 것을 해결할 수 는 없다. **3개 이상의 노드를 포함한 루프는 포이즌 리버스로는 감지할 수 없다**.

#### 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교
LS 알고리즘과 DV 알고리즘은 서로 대비되는 방법을 취한다. 먼저 DV 알고리즘은 **직접 연결한 이웃과 상호작용**하지만, LS 알고리즘은 **모든 노드**와 상호작용하고, 전체 정보를 필요로 한다. 밑은 두 알고리즘의 차이성이다.
- **메시지 복합성** : **LS 알고리즘**에서는 각 링크 비용을 모두 알아야 하고** O(|N| |E|)의 메세지가 전달**되어야 한다. 또한, 링크 비용이 변할 때마다 **새로운 링크 비용이 모든 노드에게 전달**되어야 한다. **거리벡터 알고리즘**에서는 **매번 반복**하고, 이웃한 노드들끼리 **메세지를 교환**한다. 이때, 링크 비용이 변하고, 노드의 **최소 비용 경로에 변화**를 준 경우 수정된 **링크 비용을 전파**한다.

- **수렴 속도** : **LS 알고리즘**은 **n^2 복잡도**의 알고리즘이다. 거리벡터 알고리즘은 **천천히 수렴**하고, **라우팅 루프**가 발생할 수 있다.

- **견고성** : 만약 라우터가 고장났을 경우 **LS 알고리즘**에서는 **이상한 값을 전달**할 수 있다. 또한, 노드에서 **변질된 값을 전달**할 수도 있다. 그러나, 자신의 테이블 것만 계산하기 때문에 **분산되어 수행**되며 어느 정도 **견고성**을 갖는다. 그러나, **거리 벡터 알고리즘**에서 노드는 최소 비용 경로를 **일부 혹은 모든 목적지**에 직접적으로나 간접적으로 알리기 때문에 **전체로 확산**될 수 있다.

결국 어떠한 알고리즘이 더 낫다라고는 말할 수 없고, 실제로 현장에서도 두 알고리즘이 모두 사용된다.

