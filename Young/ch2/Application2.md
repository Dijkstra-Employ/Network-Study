## 2.2. The Web and HTTP
### HTTP의 개요
웹의 Application Layer Protocols인 HTTP는 웹의 핵심이다. 
HTTP는 두 가지 프로그램으로 구현되어 있다.
- clinent program
- server program
두 프로그램은 서로 다른 end systems에 있으면서 HTTP messages를 교환한다. HTTP는 **메세지의 구조와 client와 서버가 메세지를 교환하는 방법을 정의**한다. 더 자세하게는, HTTP는 웹 클라이언트(웹 브라우저)가 웹 서버에 웹 페이지를 요청하는 방식과 서버가 웹 페이지를 응답하는 방법을 정의한다. (기본적으로 TCP 프로토콜 사용)

![](https://velog.velcdn.com/images/choiyoung6609/post/71490e85-904c-4aef-93eb-d1ea43474127/image.png)

**통신 단계**
1. 클라이언트와 서버는 TCP 연결을 시작한다.
2. TCP가 연결되면 소켓 인터페이스를 통해 TCP에 액세스한다.
3. 클라이언트와 서버 측에서는 HTTP 메세지를 소켓 인터페이스를 통해서 전달한다. 

++) HTTP는 클라이언트에 대한 정보를 저장하지 않기 때문에 상태 비저장 프로토콜이다. 

---

### Non-persistent and Persistent Connections
tcp connection을 사용하는 방법에 따라 2개로 구분할 수 있다.

- Non-persistent HTTP : 연결 후 끊는 HTTP, 다시 통신하고 싶으면 TCP 연결부터 다시 시작해야 한다.
- Persistent HTTP : 연결이 된 후 TCP를 끊지 않고 계속 이용한다.

HTTP는 기본 모드에서 Persistent HTTP를 사용하지만 Non-persistent HTTP를 사용하도록 할 수도 있다.

#### HTTP with Non-Persistent Connections
![](https://velog.velcdn.com/images/choiyoung6609/post/04bf3e58-2471-4e46-abbc-4cf423a90b36/image.png)

실제로는 병렬 연결을 통해서 응답시간이 단축된다. 이러한 비지속적 HTTP는 각 객체마다 새로운 연결을 설정하고 유지해야 하기 때문에 웹 서버에 상당한 부담이 된다. 또한 각 객체는 RTT의 전달 지연을 겪는다. 

---

### HTTP Message Format
![](https://velog.velcdn.com/images/choiyoung6609/post/bee02392-1394-40a9-ade9-cb3232ac0577/image.png)

- 일반 아스키 코드로 작성되어 있다.
- 각 줄마다 캐리지 리턴과 줄 바꿈이 따른다.
- Request Line :  요청 라인에는 method 필드, URL 필드, HTTP version 필드가 있다. 대부분의 HTTP 요청 메세지는 GET 메서드를 사용한다.(객체를 요청할 때 사용)
- Header line :  객체가 상주하는 호스트를 지정한다.(웹 프록시 캐시에 필요)
- Connection line : close라고 표현함으로써 요청된 객체를 보낸 후 서버가 연결을 닫기를 원한다.
- User Agent : 서버에 요청하는 브라우저 유형을 지정한다. 
- Accept 언어 : 해당 객체가 서버에 존재하는 경우 해당 객체의 특정한 언어 버전 수신을 선호함을 나타낸ㄷ. 그렇지 않으면 기본 버전을 보낼 수도 있다. 

일반적인 HTTP는 위의 그림과 같은 형식을 따른다. Post 메서드일 때는 Entity Body가 채워진다. 

---

### HTTP Response Message
![](https://velog.velcdn.com/images/choiyoung6609/post/b04f32ca-f049-465c-be53-353add2b8e06/image.png)

- status line : 프로토콜 버전 필드, 상태 코드 및 해당 상태 메세지가 포함된다. 
- header line : Connection, Date 등을 표시할 수 있다. 

---

### User-Server Interaction : Cookies
HTTP는 상태 비저장이지만, 서버가 사용자 액세스를 제한하기를 원하기 떄문에 웹 사이트에서 사용자를 식별하고자 한다. [RFS 6265] 에 정의된 쿠키를 사용하면 사이트에서 사용자를 추적할 수 있다.

#### 쿠키 기술의 네 가지 구성 요소
- HTTP 응답 메세지의 쿠키 헤더 라인
- HTTP 요청 메세지의 쿠키 헤더 라인
- 사용자의 end system에 보관되고 사용자의 브라우저에서 관리되는 쿠키 파일
- 웹사이트의 백엔드 데이터베이스 

1. 웹 서버에 요청이 들어올 때 서버는 유일한 식별번호를 만들고 백엔드 데이터베이스 안에 항목을 생성한다.
2. 웹 서버는 HTTP 응답에 set-cookie 헤더로 식별 번호를 보낸다.
3. 브라우저가 응답 메세지를 받고 나서 브라우저가 관리하는 특수 쿠키 파일에 한 줄을 추가한다. -> 서버의 호스트 이름과 헤더의 식별 번호
4. 웹 브라우저는 HTTP 요청 시 식별번호를 포함하여 쿠키 헤더 파일을 넣는다.

---
### Web Caching
프록시 서버라고도 하는 웹 캐시는 원본 웹 서버를 대신해서 HTTP 요청을 충족시키는 네트워크 엔티티이다. 웹 캐시에는 자체 디스크 저장소가 있어서 이 저장소에 최근 요청된 개체의 복사본을 보관한다. 

웹 캐싱은 두 가지 이유로 인터넷에 배포되었다.
1. 클라이언트 요청에 대한 응답 시간을 크게 줄여준다.
2. 인터넷 액세스 링크 트래픽을 상당히 줄일 수 있다. 트래픽을 줄임으로써 대역폭을 빠르게 업그레이드 할 필요성이 없어져서 비용이 절감된다.

> ⭐ 실제로, 두 개의 네트워크(기관 네트워크와 공용 인터넷)이 있다고 가정해보자. 기관 네트워크는 고속 LAN이기 때문에 거의 지연이 발생하지 않는다. 그러나 인터넷 라우터에서 기관 라우터까지 액세스 링크의 트래픽 강도는 1에 가깝기 때문에 **응답 시간이 몇 분정도**걸린다. 이를 해결하기 위해서 액세스 속도를 높일 수 있지만 비용이 많이 든다. 이를 해결하기 위해서 **웹 캐시를 설치하는 대체 솔루션을 사용하는 것이다.** 캐시가 0.4의 적중률을 가지고 있다고 하면, 40%는 즉각적으로 응답가능하고 액세스 링크를 통과하는 개체가 60%로 줄었기 때문에 액세스 링크의 트래픽 강도가 감소한다.

---

### 응답 메세지 우선순위 지정 및 서버 푸시
메세지 우선순위 지정을 통해서 개발자는 요청의 상대적 우선순위를 사용자 정의할 수 있다.(애플리케이션 성능 최적화) **클라이언트가 서버에 동시 요청을 보낼 때 각 메세지에 1에서 256사이의 가중치를 할당하여 요청하는 응답의 우선 순위를 지정**하는 것이다. 이 외에도, 클라이언트는 종속된 메세지의 ID를 지정하여 각 메세지의 다른 메세지에 대한 종속성을 명시한다.

HTTP/2의 또 다른 기능으로는 서버가 단일 클라이언트 요청에 추가 개체를 푸시할 수 있다는 것이다. 이러한 서버 푸시는 요청 대기로 인한 추가 대기 시간을 제거한다.

HTTP/3은 QUIC를 통해서 작동하도록 설계된 새로운 HTTP 프로토콜이다. QUIC에는 다중화, 스트림별 흐름 제어, 낮은 대기 시간 설정 등 여러 기능이 포함되어 있다. 
