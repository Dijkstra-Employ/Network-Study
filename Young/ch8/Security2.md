## 8.2 암호화 원리
암호 기술은 **송신자가 데이터를 변형**시켜 침입자가 가로챈 정보로부터 **아무런 정보도 얻지 못하도록**하기 위한 것이다. 물론, 수신자는 변형된 데이터로부터 **원래 데이터를 복원**해낼 수 있다. 

>
**평문 또는 원문** : 암호화되기 전의 문장
**암호화 알고리즘** : 평문을 암호화해주는 알고리즘
**암호문** : 암호화 알고리즘을 통해 암호화된 메세지
**대칭키 시스템** : 메세지를 주고받는 사람들의 키가 동일하고, 이 키는 **비밀**로 유지된다.
**공개키 시스템** : **한 쌍의 키**가 사용되며 키 하나는 공개되고, 나머지 하나는 둘 중 한 명만 알고 있다.

### 8.2.1 대칭키 암호화 
모든 암호화 알고리즘은 어떤 것을 다른 것으로 **대치**하는 것이다. 먼저 가장 오래된 대칭키 알고리즘인 **카이사르 암호**를 살펴보자

카이사르 암호에서는 알파벳을 각 철자에서 k번째 뒤에 오는 철자로 대치한다. 
![](https://velog.velcdn.com/images/choiyoung6609/post/6e90df23-4c49-4358-8840-503e70d0611c/image.png)

이러한 카이사르 암호는 25가지의 키만 사용되었기 때문에 해독하기 쉽다. 따라서 카이사르 암호를 개선하여 한 문자를 다른 문자로 대치하는 **단일 문자 대응 암호**로 발전하였다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/48dd81f4-c9d9-44f9-ac0c-a152b3c36d8a/image.png)

이는 **일정한 규칙**이 있는 대신에 각 철자들은 **고유한 대응문자**로 변환된다. 이는 25가지 키보다 더 많은 26! 만큼의 문자 대응쌍이 가능해진다. 

그러나, 사실 **평문에 대한 통계 분석**을 사용하면 이 또한 쉽게 해독된다.(모음, 함께 나타나는 규칙성 등) 게다가 침입자가 이미 몇 개의 단어를 파악하고 있다면 해독이 쉬워진다. 

트루디가 밥과 앨리스의 암호 기법을 얼마나 쉽게 해독할 수 있을지를 분석하려 할 떄는 침입자가 어떤 정보를 갖고 있느냐에 따라서 다음과 같은 세 가지 시나리오를 생각할 수 있다.

- **암호문만을 이용한 공격** : 침입자가 평문 메세지의 내용에 어떤 사전 정보도 없이가로챈 암호문에만 접근할 수 있는 경우다. **암호문만을 위한 공격**에 통계 분석이 어떻게 도움이 되는지 살펴봤다. 

- **알려진 평문 공격** : 트루디가 몇 개의 단어가 나타날 것을 파악하고 있다면 이것을 **알려진 평문 공격**이라고 한다. 

- **선택 평문 공격** : 침입자는 특정 평문 메세지를 선택하여 이에 대응하는 암호문 형태를 얻을 수 있다. 예를 들어 트루디가 앨리스에게 메세지를 보낼 수 있다면 암호 기법을 완벽하게 깰 수 있다. (그러나, 거의 유용하지 않다. -막혔음)


이러한 단일 문자 대응 암호법을 개선한 알고리즘에는 **다중 문자 대응 암호화**가 있다. 

> 여러 개의 단일 문자 대응법을 가지ㅗㄱ **평문 메세지에서의 위치에 따라** 서로 **다른 단일 문자 대응 암호법**을 사용하는 것

예를 들어 C1은 k=5 카이사르 암호화라고 하고, C2는 k=19 카이사르 암호화라고 할 떄 두 개를 번갈아가면서 첫 번째 문자는 C1 사용, 두 번쨰는 C2 사용, C1C2C1C2... 이런식으로 사용해나가는 것이다. 


#### 블록 암호화
이번에는 실제 오늘날 사용되는 **대칭키 암호화** 방법에 대해서 알아보자.

![](https://velog.velcdn.com/images/choiyoung6609/post/bc55f552-3b63-4052-8460-9abd6b674f46/image.png)


블록 암호화에서는 **메세지가 k 비트의 블록 단위로 암호화**된다. 즉, k=64라면 64비트의 블록들로 쪼개어 **독립적으로 암호화**한다. (일대일 사상)

만약 3비트 블록 암호화일 경우 얼마나 많은 사상이 가능할까? 8개의 비트 종류가 있다고 할 떄 이것의 순열을 구하면 40320개가 된다. 즉, 총 40320 가지의 사상표가 존재한다. 

이 암호 기법에 대한 가장 간단한 공격은 무작정 모든 사상을 시도하는 것이다. 이는 PC로 간단하게 할 수 있기 때문에 보통 볼록의 크기가 크도록(64개 정도) 하여 사상의 개수를 크게 한다. 2^k!

이렇게 k 값에 대해 입력 가능한 모든 블록에 대응하는 출력 블록을 가진 테이블 기반 블록 암호화는 **매우 안전**하지만, **구현이 어렵다**. 왜냐하면 앨리스와 밥이 **해당 사상에 대한 테이블을 유지**해야 하는데 이는 거의 불가능하다. 또한, 앨리스와 밥이 테이블을 바꾸면 다시 재생성해야 하므로 실제로 **사상이 미리 결정되어 있는 완전 테이블 기반 블록 암호화**는 실제 사용이 **어렵다**.

> 따라서 블록 암호화 기법에서는 **입출력 블록의 순열 테이블을 임의로 모방 생성하는 함수**를 사용한다. 

k=64개 라면 64비트의 블록을 8비트씩 8개의 청크로 나눈다. 이떄 8비트 청크는 **관리 가능한 크기인 8비트 입력 블록에 대응하는 8비트 출력 블록을 가진 테이블**에 의해 처리된다. 이렇게 처리된 청크들은 **하나의 64비트 출력**으로 모이게 된다. 이 출력은 **다시 입력부**로 넘어가서 **새로운 사이클**이 시작된다. 이를 n번 반복하고 나면 **64비트 암호문 블록**이 생성된다. 

이렇게 **n번 반복하는 이유**는 각 입력비트가 **대부분의 최종 출력 비트들에 영향**을 끼치도록 하기 위해서이다. 이 블록 암호화 알고리즘의 키는 **8개의 순열 테이블**이다.(비트를 뒤섞는 규칙이 이미 공개되어 있다고 가정)

오늘날 사용하는 블록 암호화 방법에는 **DES, 3DES, AES**가 있다. 이때 암호화 알고리즘의 키는 알고리즘 내부에서 특정 **미니 테이블**의 사상과 순열을 결정한다. 이 암호화 기법을 해독하기 위해서는 **모든 키를 순환**하며 모든 **복화화 알고리즘**을 수행해봐야 한다. 키의 길이가 n이면 2^n개의 가능한 키가 있다. 

이러한 블록 암호화 방법이 **대칭키 알고리즘**인 이유는 암호화와 복호화에 **사용하는 키**가 서로 같기 떄문이다. 


#### 암호 블록 체이닝
일반적으로 긴 메세지를 암호화할 때 블록 암호화를 사용하면 사소한 문제가 발생한다. **2개 이상의 평문 블록이 동일할 때** 블록 암호화 기법에서는 **항상 같은 암호문**을 생성해낸다는 것이다. 즉, 공격자가 동일한 암호문을 발견했을 때 **원본을 추측**해낼 수 있는 가능성이 존재하고, 하위 프로토콜에 대한 지식까지 있으면 전체 메세지를 **복호화**할 수 있게 된다.

이를 해결하기 위해서 **동일한 평문 블록**을 사용하더라도 **다른 암호문 블록**이 생성될 수 있도록 **임의성**을 추가하였다. 바로 **배타적 논리합(XOR)**을 이용하는 것이다.
ci : 암호화된 블록, ri : 임의의 수, Ks : 암호화알고리즘, m(i) = 평문
1) ci = Ks(m(i) + r(i))를 계산
2) 수신자에게 c1,r1,c2,r2, ...를 보냄
3) 수신자는 m(i) = Ks(c(i) + r(i)를 계산

이런 식으로 전송하게 되면 공격자가 **r(i)값**을 알게되어도 **key를 모르기 때문에** 복호화할 수 없다. 

그러나 이 알고리즘의 문제는 **두 배 많은 비트를 전송**해야 하기 때문에 **두 배 많은 대역폭**을 필요로 한다는 것이다. 이를 해결하기 위해서 **암호 블록 체이닝(CBC)**이라는 기법을 사용한다.

> 첫 번째 메세지와 함께 임의의 수를 한 번만 전송하고 이후의 임의의 수로는 직전에 계산된 암호화 블록을 대신 사용하는 것이다.

1. 메세지와 함꼐 송신자는 **초기화 벡터**를 생성한다. 이를 c(0)이라고 하자. 
2. 첫 번째 블록에 대해서 송신자는 m(1) XOR c(0)을 계산한다. 즉, 평문의 첫 번째 블록과 배타적 논리합을 구하여 암호문 블록을 얻는다. 이를 수신자에게 전송한다.
3. i 번째 블록에 대해서 송신자는 c(i) = Ks(m(i) XOR c(i - 1))을 계산하여 암호문 블록을 생성한다.

이 방식을 이용하면 
1) 수신자가 원래 메세지를 **복구**해낼 수 있다.
2) 두 평문 블록이 동일해도 **다른 암호문**이 나온다.
3) 송신자가 초기화 벡터를 암호화하지 않아도 비밀키 S를 모르기 때문에 **복호화할 수 없다**.
4) 대역폭이 **거의 증가하지 않**는다. 


### 8.2.2 공개키 암호화
위의 공통의 **비밀 대칭키**를 유지하기 위해서는 두 관계자가 어떤 방법으로든 **키**에 대해 합의를 해야한다.(not 네트워크 상) 

> 그렇다면 비밀키를 공유하지 않고 두 관계자가 암호화 통신을 하는 것이 가능할까?

![](https://velog.velcdn.com/images/choiyoung6609/post/fbb9c30d-7e23-4b29-a5e0-6548a0dc5af5/image.png)

오늘날의 **공개키 암호화 시스템**을 사용하면 해결 가능하다. 이는 **인증**과 **전자서명**에도 사용된다.

즉, 하나의 비밀키를 공유하기 보다는 2개의 **공개키**와 **개인키**를 가지고 암호화와 복호화를 진행하는 것이다. 

위의 그림처럼 밥의 공개키를 가져와서 메세지 m을 암호화한다. 그리고 밥은 메세지 m을 받아서 개인키로 복호화한다. 그러나, 대칭키처럼 비밀키를 공유하지 않기 때문에 **송신자**가 누구인지 확인할 수 없다. 따라서 **디지털 서명**이 필요하다.(8.3절에서 공부)

#### RSA
공개키 알고리즘 중 대표적인 것은 **RSA**가 있다. RSA는 모듈로 연산을 사용한다. 

RSA와 관련된 두 가지 요소가 있다.
1) **공개키와 개인키의 선택**
2) **암호화/복호화 알고리즘**

먼저 밥은 다음과 같은 절차를 밟는다.
1) 소수 p, q를 선택한다. 이 소수의 값이 클수록 RSA를 깨기 어려워진다. 
2) n = pq, z = (p - 1)(q - 1) 값을 계산한다.
3) z와 서로소 값인 e를 선택한다.
4) ed - 1이 z로 나뉘어지도록 하는 숫자 d를 찾는다. 
5) 공개키는 (n, e)로 설정, 개인키는 (n, d)를 사용한다.

다음은 앨리스의 암호화와 밥의 복호화이다.
- 앨리스가 m(m < n)을 보내면 앨리스는 m^e 를 수행하고 이를 n으로 나눌 떄 나머지를 암호 c라고 설정한다. 
> c = m^e mod n

- 밥은 c를 복호화하기 위해 다음을 수행한다.
> m = c^d mod n

#### 세션키
RSA에 필요한 지수 연산은 많은 시간이 필요하다. 따라서 종종 **대칭키 알고리즘**과 같이 사용된다. 즉, 데이터 암호화에 보낼 키(세션키)를 선택하여 이를 밥의 공개키로 **암호화**한다. 그리고 밥은 이를 개인키로 복호화하여 **대칭키**를 얻는다.

#### 어떻게 RSA가 동작할까?
RSA 동작원리를 이해하기 위해 다시 n = pq로 두자.

RSA 암호화 메세지 m은 모둘로 n 연산을 통해c가 된다.
c = m^e mod n
복호화는 이를 d 제곱하여 다시 n으로 모듈로 연산을 한다. 따라서 (m^e mod n)^d mod n이다.

모듈러 연산의 **중요한 성질** 중 하나는 모든 값 a, n, d에 대해 (a mod n)^d mod n = a^d mod n이라는 것이다. 

따라서 (m^e mod n)^d mod n이 식도 m^(ed) mod n이 된다.

이제 남은 것은 m^ed mod n = m이 되는 것을 보여주면 된다. 이때 n = pq, z = (p - 1)(q - 1) 이면, x^y mod n은 x^(y mod z) mod n이 된다는 것을 이용하면 된다.

즉 m^ed mod n = m(ed mod z) mod n = m mod n = m이 된다. 

RSA 알고리즘은 **공개값 n**을 인수분해하여 2개의 소수 p와 q를 찾는 빠른 알고리즘이 알려져 있지 않다는 점에서 기반한다. 만약 소수 p와 q를 알게 될 경우 비밀키 d를 알아낼 수 있다 .
