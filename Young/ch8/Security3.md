## 8.3 메세지 무결성과 전자서명
앞 절에서는 **암호화**를 이용하여 **기밀성**을 제공하는 방법에 대해 공부하였다. 그렇다면 **메세지 무결성**을 지키기 위해서는 어떻게 해야 할까?

메세지 무결성을 지키기 위해서는 다음 두 가지를 보장해야 한다.
1) **메세지가 정말 앨리스에게 온 것일까?**
2) **밥에게 전달되는 도중 메세지가 변경되지는 않았는가?**

이를 위해서는 메세지 무결성 기술과 함께 암호화 해시 함수에 대해 알아야 한다.

### 8.3.1 암호화 해시 함수
해시 함수는 m을 입력 받아서 해시라 불리는 **고정된 크기의 문자열 H(m)을 계산**해 낸다. 인터넷 체크섬이나 CRC 역시 이에 들어맞는다. 그러나 **암호화 해시 함수**는 특히 ** H(x) = H(y) 가 되는 서로 다른 두 메세지 x와 y를 찾는 일이 산술적으로 불가능**해야 된다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/e60ca219-4388-4196-9aaf-e62bd0d4c1a1/image.png)

즉, 침입자가 다른 메세지 y를 위조해낼 수 없어야 한다. 따라서 (m, H(m))을 보냈을 때 수신자가 H(m)을 계산한 값과 송신자가 보낸 H(m)이 같다면 **변조되지 않았다는 것**이다.

### 8.3.2 메세지 인증 코드
메세지 무결성 문제로 돌아가보자

1) 앨리스는 메세지 m을 생성하고 해시 H(m)을 계산한다.
2) 메세지 m에 H(m)을 첨부하여 확장 메세지를 생성한 후 밥에게 보낸다.
3) 밥은 (m, h)를 받고 h = H(m)인지 비교한다. 

**그러나 이때 침입자가 자신이 앨리스라고 속인 후 m', H(m')를 보낼** 수도 있다. 이를 위해서는 암호화 해시 함수 외에 **비밀키 s**가 필요하다. 이 공유 비밀키는 **인증키**라고도 한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/c9f0c4f7-af4b-4eee-b5c1-756e9d6809da/image.png)

1) 앨리스는 메세지 m을 생성한 후 s와 접합하여 m + s를 얻는다. 그런 다음 해시 H(m + s)를 계산해낸다. 이를 **메세지 인증 코드**라고 한다.
2) 앨리스는 MAC을 m과 함꼐 첨부하여 보낸다.
3) 밥은 (m, h) 값을 받으면 이미 알고 있는 s를 이용하여 MAC H(m + s)를 계산한다. 만약 두 값이 같다면 아무 문제가 없다고 판단한다. 

MAC의 특징 중 하나는 **암호화 알고리즘**을 사용하지 않고 **무결성**을 지킬 수 있다. 따라서 OSPF같은 라우팅 프로토콜은 무결성만 중요하기 떄문에 복잡한 암호화 알고리즘을 사용하지 않고도 메세지를 인증할 수 있다. 

### 8.3.3 전자서명
디지털 세계에서 문서의 소유자 또는 작성자를 명시하거나 동의의 표현으로 사용되는 것을 **전자서명**이라고 한다.

이때 이 전자서명은 **서명자를 입증**할 수 있어야 하고, **위조가 불가능**하도록 되어야 한다. 이를 위해서 전자서명에는 **밥의 고유한 무엇**을 넣어야 한다. 즉, **고유 비밀키**를 첨부하는 MAC을 고려해볼 수 있다. **그러나** MAC의 키는 밥과 앨리스가 공유하기 떄문에 **전자서명으로 적합하지 않다.**

따라서 **공개키 암호화 기술**을 사용하여 **전자서명을 구현**하도록 하자.

**즉, 밥의 개인서명은 개인키 Kb-를 적용한 Kb-(m)이다. **

예를 들어, 앨리스가 m과 Kb-(m)을 가지고 있다고 하자. 공개키 Kb+를 Kb-(m)에 적용하면 m이 된다. 즉, **밥이 이 문서에 서명**했음을 알 수 있다. 또한, m이 변조되었다면 kb+(Kb-(m))과 m이 같지 않기 떄문에 **메세지가 변조되지 않았음**을 확인할 수 있다. 

암호화 기술을 이용한 전자서명은 **연산이 너무 과중**하다는 문제가 있다. 따라서 해시 함수를 통해서 **Kb-(H(m))**를 구한다. <H(m)의 길이가 m보다 훨씬 짧기 떄문>

#### 송신 시나리오
![](https://velog.velcdn.com/images/choiyoung6609/post/08b5f7d8-019f-427d-8f3e-ba7ea7f116af/image.png)

#### 수신 시나리오
![](https://velog.velcdn.com/images/choiyoung6609/post/05b50e2e-ed3d-4b30-92f9-b17b694e917c/image.png)

다음에서 두 해시값이 일치하다면 **무결성과 작성자의 진위**를 파악할 수 있다.

다음은 MAC과 전자서명의 차이점을 살펴보자
- MAC을 사용하기 위해 인증키를 추가하고 해시를 얻는다. 그러나 알고리즘을 사용하지는 않는다.
- 전자서명을 사용할 때 개인키로 메세지를 암호화한다. 그러므로 **인증 기관**과 함께 **공개키 하부구조**를 요구하기 때문에 더 무거운 기술이다.

#### 공격키 인증
전자서명의 중요한 것 중 하나는 **공개키 인증**이다. 즉, 어떤 공개키가 **특정 통신 개체**에 포함된 다는 것을 보증하는 것이다. 즉, 자신이 통신하고자 하는 상대 개체의 **실제 공개키**를 가지고 있는지 확인할 수 있어야 한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/7ab7c7e9-47ff-4257-9883-39b3b3af8a71/image.png)


이러한 특정 통신 개체의 것을 보증하는 일은 일반적으로 **인증기관(CA)**에서 담당한다.

1. CA는 어떤 개체의 신분을 확인해준다. (적절한 방법으로) 
2. CA가 개체의 신원을 확인하면, CA는 **공개키와 신분확인서**를 결합한 **인증서**를 만든다. 이 인증서는 공개키와 함께 식별정보(IP 주소 등)을 담고 있다. 이 인증서에는 CA가 **전자서명**을 한다. 

![](https://velog.velcdn.com/images/choiyoung6609/post/d7a75423-a637-4a7f-bafc-3243d452941b/image.png)

먼저 밥은 CA로부터 인증서를 받아서 이를 함께 수신한다. 그러면 앨리스는 CA 공개키를 사용하여 밥의 인증서 유효성을 검사하고 밥의 공개키를 뽑아낸다. 
