# 5.2 라우팅 알고리즘

## 라우팅 알고리즘

- `송신자`부터 `수신자`까지 **라우터의 네트워크를 통과하는 최소 비용 경로를 결정**하는 것
- 그래프 `G(N,E)`
    - `N` : 노드 = 라우터
    - `E` : 엣지 = 물리 링크
        - 비용을 나타낸다.
        - 물리적인 거리, 링크 속도, 금전 비용 등을 반영한다.
    - 무방향성 그래프만을 반영한다.
- 최소 비용 경로
    - 모든 에지가 같은 비용을 갖는다면 최소 비용 경로는 최단 경로이다.

### 중앙 집중 vs 분산형

#### 중앙 집중형 라우팅 알고리즘

- 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다.
    - 계산은 중앙 집중된 컨트롤러에서 수행하거나 각 라우팅 모듈로 복사될 수 있다.
- `링크 상태 알고리즘(LS)` : 연결과 링크 비용에 대한 **완전한 정보**를 가진다.

#### 분산형 라우팅 알고리즘

- 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
- `거리 벡터 알고리즘(DV)` : 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고있지 않다.
    - 각 노드는 자신에 직접 연결된 링크에 대한 비용 정보만 가진다.
    - `반복된 계산`과 `이웃 노드간의 정보 교환`을 통해 노드는 목적지까지의 **최소 비용 경로를 계산**한다.
    - 각 노드는 다른 노드까지의 비용의 추정값을 벡터 형태로 유지한다.

### 정적 라우팅 vs 동적 라우팅

#### 정적 라우팅 알고리즘

- 사람이 개입한 결과로 아주 느리게 경로를 변경시킨다.

#### 동적 라우팅 알고리즘

- `네트워크 트래픽 부하`나 `토폴로지 변화`에 따라 라우팅 경로를 바꾼다.
    - 주기적으로, 혹은 토폴로지나 링크 비용의 변경에 직접적으로 응답하는 방식으로 수행된다.
- 네트워크 변화에 더 빠르게 대응할 수 있지만, 경로의 루프나 경로 진동과 같은 문제에 취약하다.

### 부하 민감

#### 부하 민감한 알고리즘

- 링크 비용은 해당 링크의 현재 혼잡 수준을 나타내기 위해 동적으로 변한다.
- 오늘날 인터넷 라우팅 알고리즘(`RIP`, `OSPF`, `BGP`)는 **링크 비용이 현재의 혼잡을 반영하지 않으므로 부하에 민감하지 않다.**

## 5.2.1 링크 상태 라우팅 알고리즘

- 네트워크 토폴로지와 모든 링크 비용이 알려져있다.

### 링크 상태 브로드캐스트 알고리즘 (=다익스트라 알고리즘)

- 각 노드가 자신과 연결된 링크의 식별자와 비용을 포함하는 `링크 상태 패킷`을 네트워크 상의 모든 다른 노드로 **브로드캐스팅**한다.
    - 모든 노드는 네트워크에 대한 `동일한 관점`을 갖게 된다.
- `다익스트라 알고리즘` : 하나의 노드에서 네트워크 내 모든 다른 노드로의 `최소 비용 경로`를 계산한다.
    - 알고리즘의 k번째 반복에서는 k개의 목적지 노드에 대한 최소 비용 경로를 알 수 있다.
- `O(n^2)`의 시간복잡도를 갖는다.
    - 힙을 이용해서 로그급수시간으로 줄일 수 있다.
    - 각 라우터는 독립적으로 `다익스트라 알고리즘`을 수행한다.

#### 진동 문제

- 네트워크에서 **패킷의 경로가 빈번하게 변경**되는 현상
    - 네트워크 링크의 혼잡도가 계속 변화
    - 라우터가 실시간으로 혼잡 정보를 기반으로 경로 조정
- 해결 방법: `동기화된 업데이트`
    - 모든 라우터가 동시에 네트워크 상태 정보를 업데이트하면 된다.
    - 연구자들은 인터넷 라우터들이 스스로 자기들끼리 동기를 맞춘다는 사실을 발견했다.

## 5.2.2 거리 벡터 라우팅 알고리즘

- 반복적이고 비동기적이고 분산적이다.
    - `반복적` : 이웃끼리 더이상 정보를 교환하지 않을때까지 프로세스가 지속된다.
    - `비동기적` : 모든 노드가 동기적으로 알고리즘을 실행할 필요가 없다.
    - `분산적` : 각 노드는 하나나 그 이상의 직접 연결된 이웃들로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포한다.
    - `자기 종료` : 계산을 멈추라는 신호 없어도 알아서 멈춘다.
- 분산적이고 네트워크의 정보를 미리 다 알필요가 없다.
    - 자신에게 직접 연결된 **이웃으로의 링크 비용과 그 이웃들로부터 수신하는 정보를 이용**한다.
- 많은 라우팅 알고리즘에서 사용된다.
    - RIP, BGP, ...

### 벨만 포드 알고리즘

- 최소 비용 경로

```
D(x, y) = min { c(x,v) + D(v,y) }
```

### 링크 비용 변경과 링크 고장

- 노드가 자신과 이웃사이의 `링크 비용`이 변경된 것을 알게 되면, 자신의 `거리 벡터`를 갱신하고 `최소 비용 경로`에 변화가 있다면 이웃에게 새로운 `거리 벡터`를 보낸다.
- `라우팅 루프 문제` : 두 노드 사이에 영원히 패킷이 순환하는 것
    - 무한 계수 문제
- `포이즌 리버스` : 노드가 특정 목적지로 가는 경로로 사용하는 이웃 노드에게 해당 목적지까지의 거리를 무한대로 알리는 기법
    - A->B->C 일때, A는 B에게 C까지의 경로(A->C)가 무한대임을 알려서 선택된 경로로만 이동하도록 한다.
    - 세 개 이상의 노드를 포함한 루프는 포이즌 리버스로는 감지할 수 없다.

### 링크 상태 알고리즘 vs 거리 벡터 라우팅 알고리즘

- `링크 상태 알고리즘` : 전체 정보를 필요로 한다.
    - 각 노드는 자신과 직접 연결된 링크의 비용을 알린다(브로드캐스팅).
- `거리 벡터 알고리즘`: 각 노드는 오직 직접 연결된 이웃과의 메세지를 교환한다.
    - 자신으로부터 네트워크 내 모든 노드들로의 최소 비용 추정값을 제공한다.

- 메세지 복잡성
    - 링크 상태 알고리즘: `O(NE)`개의 메세지 전송
        - 링크 비용이 변경될때마다 매번 노드에게 전달
    - 거리 벡터 알고리즘: 매번 반복마다 직접 연결된 이웃끼리 메세지 전달

- 수렴 속도
    - 링크 상태 알고리즘 : `O(N^2)`
    - 거리 벡터 알고리즘 : 천천히 수렴, 라우팅 루프와 무한 계수 문제가 일어날 수 있다.
- 견고성
    - 링크 상태 알고리즘: 각 링크 상태 테이블은 자신의 포워딩 테이블만 계산, **견고성 제공**
    - 거리 벡터 알고리즘: **한 노드의 잘못된 계산이 전체로 확산될 수 있다.**

> 두 알고리즘 모두 인터넷에서 사용되고 있다.

